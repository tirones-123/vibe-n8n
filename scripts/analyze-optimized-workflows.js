import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function analyzeOptimizedWorkflows() {
    console.log('üìä Analyse comparative des workflows optimis√©s...\n');
    
    const originalDir = path.join(__dirname, '..', 'workflows');
    const optimizedDir = path.join(__dirname, '..', 'workflows-rag-optimized');
    
    // Donn√©es pour les statistiques
    const originalStats = { files: 0, totalChars: 0, sizes: [] };
    const optimizedStats = { files: 0, totalChars: 0, sizes: [] };
    const comparisons = [];
    
    try {
        // V√©rifier que le dossier optimis√© existe
        try {
            await fs.access(optimizedDir);
        } catch {
            console.error('‚ùå Le dossier workflows-rag-optimized n\'existe pas !');
            console.log('üí° Ex√©cutez d\'abord: node scripts/optimize-workflows-rag.js');
            return;
        }

        // Lire les fichiers des deux dossiers
        const originalFiles = await fs.readdir(originalDir);
        const optimizedFiles = await fs.readdir(optimizedDir);
        
        const originalJsonFiles = originalFiles.filter(f => f.toLowerCase().endsWith('.json'));
        const optimizedJsonFiles = optimizedFiles.filter(f => f.toLowerCase().endsWith('.json'));
        
        console.log(`üìÅ Fichiers originaux : ${originalJsonFiles.length}`);
        console.log(`üìÅ Fichiers optimis√©s : ${optimizedJsonFiles.length}\n`);

        // Analyser chaque fichier en parall√®le
        for (const filename of originalJsonFiles) {
            const originalPath = path.join(originalDir, filename);
            const optimizedPath = path.join(optimizedDir, filename);
            
            try {
                // Lire les deux versions
                const [originalContent, optimizedContent] = await Promise.all([
                    fs.readFile(originalPath, 'utf8'),
                    fs.readFile(optimizedPath, 'utf8').catch(() => null) // En cas de fichier manquant
                ]);
                
                const originalSize = originalContent.length;
                originalStats.files++;
                originalStats.totalChars += originalSize;
                originalStats.sizes.push(originalSize);
                
                if (optimizedContent) {
                    const optimizedSize = optimizedContent.length;
                    optimizedStats.files++;
                    optimizedStats.totalChars += optimizedSize;
                    optimizedStats.sizes.push(optimizedSize);
                    
                    const reduction = originalSize - optimizedSize;
                    const reductionPercent = (reduction / originalSize * 100);
                    
                    comparisons.push({
                        filename,
                        originalSize,
                        optimizedSize,
                        reduction,
                        reductionPercent
                    });
                }
                
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erreur avec ${filename}: ${error.message}`);
            }
        }

        // Afficher les statistiques globales
        console.log('üìä STATISTIQUES GLOBALES\n');
        
        console.log('üìã Fichiers originaux :');
        console.log(`   - Nombre : ${originalStats.files.toLocaleString()}`);
        console.log(`   - Taille totale : ${originalStats.totalChars.toLocaleString()} caract√®res`);
        console.log(`   - Moyenne : ${Math.round(originalStats.totalChars / originalStats.files).toLocaleString()} caract√®res`);
        console.log(`   - Min/Max : ${Math.min(...originalStats.sizes).toLocaleString()} / ${Math.max(...originalStats.sizes).toLocaleString()}`);
        
        console.log('\nüìã Fichiers optimis√©s :');
        console.log(`   - Nombre : ${optimizedStats.files.toLocaleString()}`);
        console.log(`   - Taille totale : ${optimizedStats.totalChars.toLocaleString()} caract√®res`);
        console.log(`   - Moyenne : ${Math.round(optimizedStats.totalChars / optimizedStats.files).toLocaleString()} caract√®res`);
        console.log(`   - Min/Max : ${Math.min(...optimizedStats.sizes).toLocaleString()} / ${Math.max(...optimizedStats.sizes).toLocaleString()}`);
        
        // Calculs d'optimisation
        const totalReduction = originalStats.totalChars - optimizedStats.totalChars;
        const totalReductionPercent = (totalReduction / originalStats.totalChars * 100);
        const avgReductionPercent = comparisons.reduce((sum, c) => sum + c.reductionPercent, 0) / comparisons.length;
        
        console.log('\nüéØ OPTIMISATION GLOBALE :');
        console.log(`   - R√©duction totale : ${totalReduction.toLocaleString()} caract√®res (-${totalReductionPercent.toFixed(2)}%)`);
        console.log(`   - R√©duction moyenne : ${avgReductionPercent.toFixed(2)}% par fichier`);
        console.log(`   - Tokens √©conomis√©s (estimation) : ${Math.round(totalReduction / 4).toLocaleString()}`);

        // Top gains
        const topGains = comparisons
            .filter(c => c.reductionPercent > 20)
            .sort((a, b) => b.reductionPercent - a.reductionPercent)
            .slice(0, 20);
            
        console.log(`\nüèÜ TOP 20 OPTIMISATIONS (${topGains.length} fichiers avec >20% de r√©duction) :`);
        topGains.forEach((item, index) => {
            const reduction = item.reductionPercent.toFixed(1);
            const before = item.originalSize.toLocaleString();
            const after = item.optimizedSize.toLocaleString();
            console.log(`   ${index + 1}. ${item.filename}`);
            console.log(`      ${before} ‚Üí ${after} chars (-${reduction}%)`);
        });

        // R√©partition des gains
        const ranges = [
            { min: 0, max: 10, count: 0, label: '0-10%' },
            { min: 10, max: 25, count: 0, label: '10-25%' },
            { min: 25, max: 50, count: 0, label: '25-50%' },
            { min: 50, max: 75, count: 0, label: '50-75%' },
            { min: 75, max: 100, count: 0, label: '75%+' }
        ];
        
        comparisons.forEach(comp => {
            const percent = comp.reductionPercent;
            for (const range of ranges) {
                if (percent >= range.min && percent < range.max) {
                    range.count++;
                    break;
                }
            }
        });

        console.log('\nüìà R√âPARTITION DES GAINS :');
        ranges.forEach(range => {
            const percentage = (range.count / comparisons.length * 100).toFixed(1);
            console.log(`   - ${range.label} : ${range.count} fichiers (${percentage}%)`);
        });

        // Statistiques avanc√©es
        const largeFilesOriginal = originalStats.sizes.filter(size => size > 30000).length;
        const largeFilesOptimized = optimizedStats.sizes.filter(size => size > 30000).length;
        const avgSizeReduction = originalStats.totalChars / originalStats.files - optimizedStats.totalChars / optimizedStats.files;

        console.log('\nüìã IMPACT SUR LES GROS FICHIERS :');
        console.log(`   - Fichiers >30k chars avant : ${largeFilesOriginal}`);
        console.log(`   - Fichiers >30k chars apr√®s : ${largeFilesOptimized}`);
        console.log(`   - R√©duction moyenne par fichier : ${Math.round(avgSizeReduction).toLocaleString()} caract√®res`);

        // Liste des fichiers optimis√©s > 30k
        const largeOptimizedFiles = comparisons
            .filter(c => c.optimizedSize > 30000)
            .sort((a, b) => b.optimizedSize - a.optimizedSize);
            
        console.log(`\nüìã FICHIERS OPTIMIS√âS TOUJOURS >30k CARACT√àRES (${largeOptimizedFiles.length} fichiers) :`);
        largeOptimizedFiles.forEach((item, index) => {
            const reduction = item.reductionPercent.toFixed(1);
            const before = item.originalSize.toLocaleString();
            const after = item.optimizedSize.toLocaleString();
            console.log(`   ${index + 1}. ${item.filename}`);
            console.log(`      ${before} ‚Üí ${after} chars (-${reduction}%)`);
        });

        // Calcul de la m√©diane
        const sortedOriginal = [...originalStats.sizes].sort((a, b) => a - b);
        const sortedOptimized = [...optimizedStats.sizes].sort((a, b) => a - b);
        
        const medianOriginal = sortedOriginal.length % 2 === 0
            ? (sortedOriginal[sortedOriginal.length / 2 - 1] + sortedOriginal[sortedOriginal.length / 2]) / 2
            : sortedOriginal[Math.floor(sortedOriginal.length / 2)];
            
        const medianOptimized = sortedOptimized.length % 2 === 0
            ? (sortedOptimized[sortedOptimized.length / 2 - 1] + sortedOptimized[sortedOptimized.length / 2]) / 2
            : sortedOptimized[Math.floor(sortedOptimized.length / 2)];

        console.log('\nüìä M√âDIANE DU NOMBRE DE CARACT√àRES :');
        console.log(`   - M√©diane originale : ${Math.round(medianOriginal).toLocaleString()} caract√®res`);
        console.log(`   - M√©diane optimis√©e : ${Math.round(medianOptimized).toLocaleString()} caract√®res`);
        console.log(`   - R√©duction m√©diane : ${Math.round(medianOriginal - medianOptimized).toLocaleString()} caract√®res (-${((medianOriginal - medianOptimized) / medianOriginal * 100).toFixed(1)}%)`);

        // Percentiles suppl√©mentaires
        const p25Original = sortedOriginal[Math.floor(sortedOriginal.length * 0.25)];
        const p75Original = sortedOriginal[Math.floor(sortedOriginal.length * 0.75)];
        const p90Original = sortedOriginal[Math.floor(sortedOriginal.length * 0.90)];
        
        const p25Optimized = sortedOptimized[Math.floor(sortedOptimized.length * 0.25)];
        const p75Optimized = sortedOptimized[Math.floor(sortedOptimized.length * 0.75)];
        const p90Optimized = sortedOptimized[Math.floor(sortedOptimized.length * 0.90)];

        console.log('\nüìà PERCENTILES DE TAILLE :');
        console.log(`   - P25 : ${p25Original.toLocaleString()} ‚Üí ${p25Optimized.toLocaleString()} chars`);
        console.log(`   - P50 (m√©diane) : ${Math.round(medianOriginal).toLocaleString()} ‚Üí ${Math.round(medianOptimized).toLocaleString()} chars`);
        console.log(`   - P75 : ${p75Original.toLocaleString()} ‚Üí ${p75Optimized.toLocaleString()} chars`);
        console.log(`   - P90 : ${p90Original.toLocaleString()} ‚Üí ${p90Optimized.toLocaleString()} chars`);

        console.log('\nüíæ ESTIMATION POUR LE RAG :');
        const tokensSaved = Math.round(totalReduction / 4);
        const costSavedUSD = (tokensSaved * 0.00001).toFixed(2); // Estimation OpenAI pricing
        console.log(`   - Tokens √©conomis√©s : ${tokensSaved.toLocaleString()}`);
        console.log(`   - √âconomie estim√©e : ~$${costSavedUSD} USD en tokens d'embedding`);
        console.log(`   - Gain en vitesse : ~${totalReductionPercent.toFixed(1)}% plus rapide pour les embeddings`);

    } catch (error) {
        console.error('‚ùå Erreur lors de l\'analyse :', error.message);
        process.exit(1);
    }
}

// Lancer l'analyse
analyzeOptimizedWorkflows().catch(error => {
    console.error('üí• Erreur critique :', error);
    process.exit(1);
}); 