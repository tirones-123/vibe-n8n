n8n Automation Nodes Quick Reference

This quick reference provides JSON configuration snippets for common n8n nodes, categorized by function. Each snippet demonstrates how to use the node programmatically (as it would appear in a workflow's JSON). Use these examples as templates for creating workflows. (Note: Replace placeholder values ​​like YOUR_API_KEY or YOUR_ID with actual values. Identifiers are referenced by name/ID after configuration in n8n.)

AI & LLM Integrations

OpenAI Chat Model (GPT-3.5/GPT-4): Uses OpenAI's Chat API to generate responses. You specify the model, prompts, and parameters like temperature. This node can take a system prompt and a user prompt to generate a response. For example, to use the GPT-3.5 Turbo model with a system role and a user message:

```json
{
  "name": "ChatGPT",
  "type": "n8n-nodes-langchain.lmChatOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "gpt-3.5-turbo",
    "temperature": 0.7,
    "maxTokens": 500,
    "systemPrompt": "You are a helpful assistant.",
    "userPrompt": "Hello! How can I automate tasks with n8n?"
  },
  "credentials": {
    "openAiApi": {
      "id": "YOUR_CRED_ID",
      "name": "OpenAI API"
    }
  }
}
```

Explanation: This configuration sets the OpenAI Chat node to use the GPT-3.5 model with a system message providing context and a user message. The response will be available as output from the node. Make sure you have configured an OpenAI API identifier named "OpenAI API," referenced in the identifiers. You can adjust the temperature for creativity and maxTokens for the response length.

OpenAI Text Completion: For GPT-3 completion models (like text-davinci-003), you can use the OpenAI node in completion mode. Provide a prompt and parameters. For example:

```json
{
  "name": "OpenAI Completion",
  "type": "n8n-nodes-langchain.openai",
  "typeVersion": 1,
  "parameters": {
    "model": "text-davinci-003",
    "prompt": "Summarize the following text: {{$json[\"content\"]}}",
    "temperature": 0.5,
    "maxTokens": 200
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela envoie une invite à l’endpoint de complétion d’OpenAI pour résumer un contenu provenant des données d’entrée. La syntaxe `{{$json["content"]}}` insère les données du nœud précédent. Le nœud utilise les identifiants API OpenAI. Le résultat apparaît dans le JSON de sortie du nœud (champ result contenant le texte généré).

Agents IA (avec outils) : n8n prend en charge des nœuds d’Agent avancés qui permettent à un modèle IA d’utiliser des outils (comme la recherche web, les calculatrices ou d’autres fonctions de nœuds) pour accomplir des tâches. Par exemple, l’Agent avec fonctions OpenAI peut appeler des fonctions personnalisées, et l’Agent ReAct utilise la stratégie ReAct pour décider quel outil utiliser à chaque étape. Voici un exemple simplifié de configuration de nœud Agent IA utilisant un modèle OpenAI et un outil (par ex., un outil de recherche Google) :

```json
{
  "name": "Agent IA (ReAct)",
  "type": "n8n-nodes-langchain.agent",
  "typeVersion": 1,
  "parameters": {
    "agentType": "react",
    "model": "gpt-4",
    "memory": false,
    "tools": [
      {
        "name": "googleSearch",
        "input": "What is n8n?"
      }
    ]
  }
}
```

Explication : Cet agent est configuré pour utiliser la stratégie ReAct avec GPT-4. Le tableau des outils correspond à de véritables nœuds Tool connectés au nœud Agent (par exemple, un nœud de recherche Google dans le workflow). En pratique, vous ajoutez les outils via l’interface graphique (ils deviennent des sous-nœuds). L’agent décide quand utiliser l’outil. Par exemple, il pourrait utiliser l’outil Google Search pour récupérer des informations nécessaires à une réponse. Remarque : Le cluster de nœuds Agent gère la logique ; assurez-vous d’avoir configuré les bons outils et identifiants (comme les clés API Google). Les agents peuvent aussi utiliser d'autres modes comme OpenAI Functions Agent, Plan-and-Execute Agent ou SQL Agent, chacun permettant à l’IA d’exécuter des tâches complexes spécifiques (par ex. appeler des fonctions définies, découper une tâche en sous-tâches, ou exécuter des requêtes SQL via des identifiants DB).

**Vecteurs et Bases de Données Vectorielles :** n8n propose des nœuds pour générer des embeddings de texte avec des modèles (OpenAI, Cohere, Google PaLM, etc.) et pour les stocker/interroger dans des bases vectorielles (Pinecone, Weaviate, etc.). Par exemple, le nœud OpenAI Embeddings peut prendre un texte et retourner un vecteur. L’utilisation est simple : vous spécifiez le champ texte à transformer et le modèle. La sortie est généralement un tableau de nombres représentant le vecteur. Ceux-ci peuvent être utilisés avec un nœud de type Vector Store (comme Pinecone) pour insérer ou interroger des vecteurs. Exemple d’un nœud OpenAI Embedding :

```json
{
  "name": "Text to Vector",
  "type": "n8n-nodes-langchain.embeddingsOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "text-embedding-ada-002",
    "text": "={{ $json[\"content\"] }}"
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela prend le champ "content" du JSON d’entrée et génère un embedding à 1536 dimensions à l’aide du modèle ada d’OpenAI. Ce vecteur est généralement envoyé vers un stockage ou utilisé dans une recherche par similarité. Pour le stockage, un nœud Pinecone (ou autre DB vectorielle) peut être utilisé avec des opérations comme Insérer un vecteur ou Interroger un vecteur (vous fournissez le nom de l’index, les données du vecteur, et d’éventuels métadonnées ou vecteurs de requête). L’usage des bases vectorielles pouvant être complexe, consultez la documentation du nœud pour les paramètres exacts. Le concept clé est que les nœuds Embeddings convertissent du texte en vecteurs numériques, et les nœuds Vector Store permettent de stocker et interroger ces vecteurs, ce qui permet des workflows comme la recherche sémantique ou la génération augmentée par récupération.

**Intégrations API & Webhooks**

**Nœud HTTP Request (APIs REST)** : C’est le nœud universel pour appeler toute API RESTful. Vous pouvez configurer la méthode, l’URL, les en-têtes, les paramètres de requête et le corps (y compris un corps JSON). Il prend en charge l’authentification via des identifiants (OAuth2, jeton API, etc.) ou des en-têtes personnalisés. Voici un exemple de requête GET avec paramètres :

```json
{
  "name": "HTTP GET Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/data",
    "method": "GET",
    "responseFormat": "json",
    "queryParametersUi": {
      "parameter": [
        { "name": "q", "value": "search term" },
        { "name": "limit", "value": "10" }
      ]
    }
  }
}
```

Pour effectuer un POST avec un corps JSON, utilisez `jsonParameters: true` et fournissez l’objet `bodyParametersJson` (ou les données de formulaire, etc.). Exemple de requête POST :

```json
{
  "name": "HTTP POST Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/posts",
    "method": "POST",
    "responseFormat": "json",
    "jsonParameters": true,
    "options": {
      "bodyContentType": "json"
    },
    "bodyParametersJson": {
      "title": "Hello World",
      "content": "This is an example post via n8n."
    }
  },
  "credentials": {
    "httpBasicAuth": {
      "name": "Example API Auth"
    }
  }
}
```

Explication : Ce POST enverra une charge utile JSON avec `title` et `content`. On définit `bodyContentType` sur JSON pour s'assurer de l’en-tête `Content-Type: application/json`. La section des identifiants (optionnelle) peut référencer une authentification HTTP Basic, OAuth2, ou un identifiant API selon les besoins de l’API. Le nœud HTTP est très flexible – vous pouvez aussi l’utiliser pour GraphQL en envoyant une requête GraphQL dans le corps ou en utilisant le nœud dédié GraphQL.

```json
{
  "name": "GraphQL Query",
  "type": "n8n-nodes-base.graphql",
  "typeVersion": 1,
  "parameters": {
    "endpoint": "https://api.spacex.land/graphql/",
    "query": "query Launches($limit:Int!) {\n launchesPast(limit: $limit) {\n mission_name\n launch_date_utc\n }\n}",
    "variables": "{ \"limit\": 3 }",
    "headerParametersUi": {
      "parameter": [
        { "name": "Authorization", "value": "Bearer YOUR_API_TOKEN" }
      ]
    }
  }
}
```

Explication : Cela interroge l’API GraphQL de SpaceX pour les 3 derniers lancements. Un token Bearer est inclus dans les en-têtes (si l’API nécessite une authentification). Le résultat sera un JSON dans la sortie du nœud. Le nœud GraphQL envoie automatiquement la requête au format JSON à l’endpoint. Vous pouvez également intégrer des données dynamiques avec des expressions n8n dans la requête ou les variables.

---

```json
{
  "name": "Webhook Trigger",
  "type": "n8n-nodes-base.webhook",
  "typeVersion": 1,
  "parameters": {
    "path": "incoming-data",
    "methods": ["POST"],
    "responseMode": "onReceived",
    "responseData": {
      "statusCode": 200,
      "body": "Webhook received successfully"
    }
  }
}
```

Explication : Cela crée un webhook à l’URL `/webhook/incoming-data` (l’URL complète est visible dans l’interface n8n). Il écoute les requêtes POST. `responseMode: onReceived` signifie que n8n enverra immédiatement une réponse dès que la requête est reçue (sans attendre la fin du workflow), avec une réponse statique 200 OK. Pour accéder aux données de la requête, utilisez `{{$json["body"]["fieldName"]}}` dans les nœuds suivants. Idéal pour des services comme Stripe, GitHub ou des intégrations personnalisées.

---

```json
{
  "name": "Webhook Response",
  "type": "n8n-nodes-base.respondToWebhook",
  "typeVersion": 1,
  "parameters": {
    "responseMode": "responseNode",
    "options": {
      "responseData": {
        "body": "{ \"success\": true, \"message\": \"Processed\" }",
        "headers": {
          "Content-Type": "application/json"
        },
        "statusCode": 200
      }
    }
  }
}
```

Explication : Placez ce nœud à l’endroit où vous souhaitez répondre au webhook. Une fois exécuté, n8n envoie la réponse spécifiée et ne poursuit pas l’exécution des nœuds suivants. Si vous souhaitez continuer le workflow après la réponse, utilisez l’option “respond and continue”. Utile pour les cas où une réponse immédiate est nécessaire, suivie de traitements en arrière-plan.

```json
{
  "name": "Add Field",
  "type": "n8n-nodes-base.function",
  "typeVersion": 1,
  "parameters": {
    "functionCode": "for (const item of items) {\n item.json.newField = item.json.someField + 100;\n}\nreturn items;"
  }
}
```

Explication : Ce nœud de code JavaScript parcourt chaque élément d'entrée et ajoute un nouveau champ `newField` en lui assignant la valeur de `someField + 100`. Le nœud retourne les items modifiés. Vous pouvez y effectuer des transformations plus complexes ou générer des données si aucun input n'est défini.

---

```json
{
  "name": "Check Status",
  "type": "n8n-nodes-base.if",
  "typeVersion": 2,
  "parameters": {
    "conditions": {
      "conditions": [
        {
          "leftValue": "={{ $json[\"status\"] }}",
          "rightValue": "success",
          "operator": {
            "type": "string",
            "operation": "equals"
          }
        }
      ],
      "combinator": "and"
    }
  }
}
```

Explication : Ce nœud IF vérifie si le champ `status` est égal à `"success"`. Si oui, l’élément est dirigé vers la sortie vraie, sinon vers la fausse. Vous pouvez ajouter d’autres règles et les combiner avec `and` ou `or`.

---

```json
{
  "name": "Route by Category",
  "type": "n8n-nodes-base.switch",
  "typeVersion": 1,
  "parameters": {
    "dataType": "string",
    "value1": "={{ $json[\"category\"] }}",
    "rules": {
      "rules": [
        { "operation": "equal", "value2": "support" },
        { "operation": "equal", "value2": "sales" }
      ]
    },
    "fallbackOutput": 2
  }
}
```

Explication : Ce nœud Switch examine la valeur du champ `category`. Si elle vaut `"support"`, l’élément va à la sortie 0 ; si `"sales"`, à la sortie 1 ; sinon, à la sortie 2. Pratique pour diriger les données selon plusieurs cas.

---

```json
{
  "name": "Set Fields",
  "type": "n8n-nodes-base.set",
  "typeVersion": 3,
  "parameters": {
    "keepOnlySet": false,
    "values": {
      "number": [
        {
          "name": "year",
          "value": 2025
        }
      ],
      "string": [
        {
          "name": "statusMessage",
          "value": "Processed by n8n"
        }
      ]
    }
  }
}
```

Explication : Ce nœud ajoute deux champs : un nombre `year` et une chaîne `statusMessage`. Comme `keepOnlySet` est à false, les autres champs existants sont conservés. C’est utile pour enrichir ou transformer les données avant de les envoyer ailleurs.

```json
{
  "name": "Merge on ID",
  "type": "n8n-nodes-base.merge",
  "typeVersion": 1,
  "parameters": {
    "mode": "mergeByKey",
    "propertyName": "id",
    "outputDataFrom": "both"
  }
}
```

Explication : Ce nœud Merge combine deux flux de données en fonction du champ `id`. Il associe les éléments d'entrée 1 et 2 qui ont la même valeur d'identifiant. Le champ `outputDataFrom: "both"` signifie que les données fusionnées incluront les champs des deux entrées. Utilisez-le pour regrouper des données séparées après traitement parallèle.

---

```json
{
  "name": "Split Array",
  "type": "n8n-nodes-base.itemLists",
  "typeVersion": 1,
  "parameters": {
    "operation": "splitIntoItems",
    "property": "results"
  }
}
```

Explication : Ce nœud transforme un champ `results` contenant un tableau en plusieurs éléments distincts, chacun contenant un seul élément du tableau. Idéal pour gérer les réponses d’API ou des champs de données groupés.

---

```json
{
  "name": "Batch Loop",
  "type": "n8n-nodes-base.splitInBatches",
  "typeVersion": 1,
  "parameters": {
    "batchSize": 10
  }
}
```

Explication : Ce nœud permet de traiter les éléments en lots de 10. Il envoie les premiers 10 éléments, attend un retour via son entrée secondaire pour envoyer le lot suivant. Cela permet un traitement itératif (comme une boucle), utile pour limiter les appels API ou éviter une surcharge. Le processus se répète jusqu'à épuisement des éléments.

```json
{
  "name": "Stop on Condition",
  "type": "n8n-nodes-base.stopAndError",
  "typeVersion": 1,
  "parameters": {
    "message": "Terminating workflow due to business rule X"
  }
}
```

Explication : Ce nœud arrête volontairement le workflow avec un message d'erreur personnalisé. Il est utile après une condition (IF) pour bloquer l'exécution si un critère métier n'est pas respecté. L’exécution s’interrompt et une erreur est générée.

---

```json
{
  "name": "Daily Schedule",
  "type": "n8n-nodes-base.cron",
  "typeVersion": 1,
  "parameters": {
    "triggerTimes": {
      "item": [
        { "hour": 9, "minute": 0 },
        { "hour": 17, "minute": 0 }
      ]
    }
  }
}
```

Explication : Ce nœud déclenche le workflow chaque jour à 9h00 et 17h00. Il s'agit d'un déclencheur planifié via le nœud Cron. Aucun input n’est requis, et un élément vide est envoyé pour initier le workflow.

---

```json
{
  "name": "Email Trigger",
  "type": "n8n-nodes-base.emailReadImap",
  "typeVersion": 1,
  "parameters": {
    "mailbox": "INBOX",
    "postProcessAction": "read",
    "options": {
      "criteria": "UNSEEN"
    }
  },
  "credentials": {
    "imap": {
      "name": "My Email Account"
    }
  }
}
```

Explication : Ce nœud surveille la boîte de réception IMAP et déclenche le workflow à la réception d’un email non lu, qu’il marque ensuite comme lu. Il permet d’automatiser des réponses ou extractions depuis des emails entrants.

---

```json
{
  "name": "Manual Trigger",
  "type": "n8n-nodes-base.manualTrigger",
  "typeVersion": 1,
  "parameters": {}
}
```

Explication : Ce nœud démarre le workflow manuellement depuis l’interface n8n (bouton "Exécuter le workflow"). Il ne contient aucun paramètre et génère un élément vide pour initier le traitement.

---

```json
{
  "name": "Run Sub-workflow",
  "type": "n8n-nodes-base.executeWorkflow",
  "typeVersion": 1,
  "parameters": {
    "workflowId": "123",
    "waitForCompletion": true,
    "inputs": {
      "inputData": "={{ $json[\"data\"] }}"
    }
  }
}
```

Explication : Ce nœud appelle un sous-workflow (ID `123`) depuis un workflow principal. Il attend que l'exécution soit terminée (`waitForCompletion: true`) et transmet une donnée d’entrée nommée `inputData`. Le sous-workflow doit inclure un nœud `Workflow Trigger` pour recevoir l’appel.

```json
{
  "name": "Send Slack Message",
  "type": "n8n-nodes-base.slack",
  "typeVersion": 1,
  "parameters": {
    "resource": "message",
    "operation": "send",
    "channel": "C01234567",
    "text": "Hello from n8n :tada:"
  },
  "credentials": {
    "slackApi": {
      "name": "Slack OAuth2"
    }
  }
}
```

Explication : Ce nœud envoie le message "Hello from n8n 🎉" dans le canal Slack spécifié. Le canal peut être un ID ou un nom (assurez-vous que les autorisations nécessaires sont définies dans l’application Slack). Ce nœud utilise un identifiant Slack OAuth2.

---

```json
{
  "name": "Append to Sheet",
  "type": "n8n-nodes-base.googleSheets",
  "typeVersion": 4,
  "parameters": {
    "operation": "append",
    "spreadsheetId": "1A2b3C4D5E6FgHiJkLMnoPQrstu",
    "sheetName": "Sheet1",
    "dataMode": "autoMap",
    "options": {
      "valueInputMode": "USER_ENTERED"
    }
  },
  "credentials": {
    "googleSheetsOAuth2Api": {
      "name": "Google Sheets OAuth2"
    }
  }
}
```

Explication : Ce nœud ajoute une ligne à une feuille Google Sheets nommée "Sheet1". Il utilise le mode `autoMap` pour faire correspondre automatiquement les champs d'entrée avec les colonnes. Le mode `USER_ENTERED` fait en sorte que les formules soient recalculées comme si un utilisateur avait saisi les données.

---

```json
{
  "name": "Query Notion DB",
  "type": "n8n-nodes-base.notion",
  "typeVersion": 2,
  "parameters": {
    "resource": "databasePage",
    "operation": "getAll",
    "databaseId": "YOUR_NOTION_DATABASE_ID",
    "options": {
      "filter": {
        "singleCondition": {
          "key": "Email|email",
          "condition": "equals",
          "emailValue": "={{ $json[\"email\"] }}"
        }
      }
    }
  },
  "credentials": {
    "notionApi": {
      "name": "Notion API"
    }
  }
}
```

Explication : Ce nœud interroge une base de données Notion et renvoie les pages dont le champ "Email" correspond à la valeur provenant des données entrantes. Il utilise l’opération `getAll` sur la ressource `databasePage` avec un filtre conditionnel. Un identifiant d’API Notion est requis.

```json
{
  "name": "Create GitHub Issue",
  "type": "n8n-nodes-base.github",
  "typeVersion": 1,
  "parameters": {
    "resource": "issue",
    "operation": "create",
    "owner": "octocat",
    "repository": "Hello-World",
    "title": "Automated Issue from n8n",
    "body": "This issue was created by an n8n workflow."
  },
  "credentials": {
    "githubApi": {
      "name": "GitHub personal access token"
    }
  }
}
```

Explication : Ce nœud crée un ticket GitHub dans le dépôt `octocat/Hello-World`. Il utilise un token personnel GitHub configuré dans les identifiants. Vous pouvez aussi utiliser d'autres opérations sur les issues, les commits, les pull requests, etc.

---

```json
{
  "name": "MySQL Query",
  "type": "n8n-nodes-base.mySql",
  "typeVersion": 2,
  "parameters": {
    "operation": "executeQuery",
    "query": "SELECT * FROM users WHERE id = {{ $json[\"user_id\"] }}",
    "additionalFields": {}
  },
  "credentials": {
    "mySql": {
      "name": "My MySQL DB"
    }
  }
}
```

Explication : Ce nœud exécute une requête SQL personnalisée dans une base MySQL en injectant dynamiquement un `user_id`. Chaque ligne du résultat devient un item JSON. Évitez les injections SQL en contrôlant les données insérées dans les expressions.

---

Résumé des autres intégrations :

* **Notion (create/update/query pages)** : Très utile pour automatiser des tableaux de bord, notes, suivis de tâches.
* **Slack (messagerie, alertes)** : Envoi de messages, notifications automatiques, support de blocks JSON.
* **Google Sheets** : Lecture et écriture de feuilles, synchronisation de données, export automatisé.
* **GitHub** : Création de tickets, gestion des pull requests, intégration DevOps.
* **MySQL/PostgreSQL** : Intégration directe avec vos bases de données métiers pour lecture/écriture.
* **Autres services populaires :**

  * **AWS S3** : Upload/download de fichiers.
  * **Google Drive** : Gestion de fichiers cloud.
  * **Twilio** : SMS, WhatsApp.
  * **Stripe** : Paiements, événements.
  * **Jira, Trello, Asana** : Gestion de tâches.
  * **HubSpot, Salesforce** : CRM automatisé.
  * **Email SMTP / SendGrid** : Envoi d’emails transactionnels.
  * **Webhook/HTTP** : Intégration d’API ou de services personnalisés.
  * **CSV/XML** : Lecture/écriture de formats structurés.

Tous ces nœuds suivent le schéma : `resource` → `operation` → `paramètres`. Créez-les dans l’éditeur n8n, puis exportez en JSON pour les réutiliser ou les automatiser.

**Conseils d'utilisation :**

* **Expressions :**
  Les expressions comme `={{ $json["..."] }}` servent à récupérer des données d’un nœud précédent. Elles doivent être entre doubles accolades dans une chaîne JSON. n8n les évalue à l’exécution. Vous pouvez aussi utiliser `$node["NomDuNœud"].json["champ"]` pour pointer vers un champ précis d’un autre nœud, ou `$items()` pour accéder à plusieurs éléments.

* **Identifiants (Credentials) :**
  La section `"credentials"` dans chaque nœud lie le nœud à un identifiant stocké. Elle peut être de la forme `{ "id": "some-id", "name": "Credential Name" }` ou juste `"name"`. Lors de la création de workflows via l’API, le nom suffit s’il est unique. Assurez-vous que l’identifiant est bien configuré dans n8n avant usage.

* **ID de nœud et position :**
  Des champs comme `id` et `position` peuvent apparaître dans des exports. Ils ne sont pas nécessaires pour un guide comme celui-ci, mais sont utilisés par l’interface graphique pour positionner les nœuds. On peut les omettre si on se concentre uniquement sur la configuration fonctionnelle.

---

**Connexion des nœuds :**

Dans le JSON d’un workflow complet, la section `"connections"` relie les sorties des nœuds aux entrées d’autres nœuds. Exemple pour une chaîne Cron → GraphQL → Function → Slack :

```json
"connections": {
  "Cron": {
    "main": [
      [
        {
          "node": "GraphQL",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "GraphQL": {
    "main": [
      [
        {
          "node": "Summarize",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "Summarize": {
    "main": [
      [
        {
          "node": "Slack",
          "type": "main",
          "index": 0
        }
      ]
    ]
  }
}
```

Cela indique que la sortie du nœud `"Cron"` est connectée à l’entrée du nœud `"GraphQL"`, et ainsi de suite. Si vous créez un workflow via l’API, vous devez construire manuellement cette structure.

---

**Tests et itération :**
Commencez par un workflow simple (`Manual Trigger → un seul nœud → sortie`) pour valider votre structure JSON, puis ajoutez progressivement des étapes. Vous pouvez importer un JSON dans n8n via **Workflow → Import from JSON** pour le visualiser et le tester.

---

**Conclusion :**
Cette fiche a couvert les principales catégories et les nœuds les plus populaires (IA, webhooks, intégrations, traitement de données). En combinant ces exemples, vous pouvez automatiser une grande variété de processus dans n8n. Bonne automatisation !


```json
[
  {
    "json": {
      "property1": "value1",
      "property2": "value2"
    },
    "binary": {}
  },
  {
    "json": {
      "property1": "anotherValue1",
      "property2": "anotherValue2"
    },
    "binary": {}
  }
]
```

Explication : Dans n8n, les données circulent entre les nœuds sous forme d’un tableau d’objets appelés **items**. Chaque item possède une clé `json` (données structurées) et une clé `binary` (fichiers, le cas échéant). Les nœuds traitent chaque item individuellement, ce qui permet un traitement parallèle.

---

### Accès aux données avec les expressions

* `{{ $json.property1 }}` – accède à un champ simple.
* `{{ $json.parent.child.property }}` – accède à une propriété imbriquée.
* `{{ $node["NomDuNœud"].json.property }}` – accède aux données d’un autre nœud spécifique.

---

### Exemple – nœud Set en mode de mappage manuel :

```json
{
  "newField": "{{ $json.existingField }}",
  "combinedField": "{{ $json.firstName }} {{ $json.lastName }}",
  "staticField": "This is a static value"
}
```

Explication : Ce nœud crée trois champs :

* `newField` reprend la valeur d’un champ existant.
* `combinedField` combine deux champs.
* `staticField` insère une valeur fixe.

---

### Exemple – mode JSON Output du nœud Set :

```json
{
  "mode": "jsonOutput",
  "jsonOutput": {
    "newField": "{{ $json.existingField }}",
    "processedData": {
      "id": "{{ $json.id }}",
      "timestamp": "{{ $now }}"
    }
  }
}
```

Explication : Cette configuration produit une structure JSON personnalisée contenant un champ `newField` et un objet imbriqué `processedData` avec un ID et un horodatage dynamique.

---

### Prise en charge de la notation par point (dot notation)

```json
{
  "number": {
    "one": 20
  }
}
```

* Si vous utilisez `"name": "number.one"` avec une valeur `20`, le champ sera interprété comme `number.one` → `number: { one: 20 }`.
* Pour désactiver cela, ajoutez l’option `"supportDotNotation": false`.

---

### Nœud Code – transformations programmatiques

Le nœud **Code** (anciennement Function) permet de manipuler les données avec du **JavaScript** (ou Python, si activé). Il peut générer des données ou transformer les items entrants. Deux modes principaux :

* **Item-wise (par élément)** – boucle automatique sur chaque item
* **Manual/Batch** – contrôle complet sur `items[]` et retour groupé

Exemple simple en JavaScript :

```javascript
for (const item of items) {
  item.json.processed = true;
  item.json.fullName = `${item.json.firstName} ${item.json.lastName}`;
}
return items;
```

Explication : Ce code ajoute un champ `processed` à `true` et génère un champ `fullName` à partir des données existantes.

---

Cette section complète la fiche ultime n8n avec une compréhension approfondie du format de données, des expressions, du nœud Set, et de l’utilisation avancée du nœud Code.

```javascript
// Run Once for All Items
const newItems = [];

const inputData = $input.all().json;

for (const item of inputData) {
  newItems.push({
    json: {
      modifiedData: item.originalData,
      timestamp: new Date().toISOString()
    }
  });
}

return newItems;
```

Explication : Ce script traite tous les items en une seule fois. Il accède à tous les objets d'entrée avec `$input.all().json`, les transforme, et retourne un nouveau tableau.

---

```javascript
// Run Once for Each Item
const item = $json;

item.processed = true;
item.modifiedAt = new Date().toISOString();

return { json: item };
```

Explication : Ce script modifie chaque item indépendamment, ajoutant deux champs : `processed` et `modifiedAt`. Il retourne l’item enrichi.

---

```javascript
// Splitting JSON into Separate Items
let results = [];

for (const item of $('Webhook').all()) {
  const students = item.json.body.students;
  for (studentKey of Object.keys(students)) {
    results.push({
      json: students[studentKey]
    });
  }
}

return results;
```

Explication : Ce code prend une réponse JSON avec des données imbriquées (ici des étudiants) et les convertit en items individuels. Utile pour traiter chaque élément séparément dans les workflows.

---

### Syntaxe d'expressions de base

* `{{ $json.city }}` : Accède à la propriété `city` d’un JSON entrant, typiquement d’un webhook.
* `{{ $node["NodeName"].json.property }}` : Récupère une valeur d’un nœud spécifique précédent.

---

### Exemple de configuration d’un AI Agent (LangChain)

**Agent avec outils :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

**Agent conversationnel :**

```json
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

**Agent avec mémoire persistante :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Export et import de workflows

Les workflows n8n sont sauvegardés au format JSON. Cela permet :

* de les importer/exporter facilement,
* de les versionner,
* de les partager ou les déployer automatiquement via API ou CLI.

Pour importer : **Menu Workflow → Import from JSON**.
Pour exporter : **Menu Workflow → Export → Copy JSON**.

C’est idéal pour collaborer, sauvegarder ou migrer vos automatisations.

```json
// XML to JSON Converter
{
  "operation": "convert",
  "source": "xml",
  "target": "json",
  "data": "{{ $json.xmlData }}"
}
```

```json
// CSV to JSON Converter
{
  "operation": "convert",
  "source": "csv",
  "target": "json",
  "data": "{{ $json.csvData }}"
}
```

```json
// Google Sheets Integration - Append or Update
{
  "operation": "appendOrUpdate",
  "sheetId": "YOUR_SHEET_ID",
  "range": "A:Z",
  "data": "{{ $json.rowData }}"
}
```

```json
// OpenAI Node to Generate Structured JSON
{
  "model": "gpt-4",
  "prompt": "Generate a JSON object with the following structure: {{ $json.structure }}",
  "temperature": 0.2,
  "output": "json"
}
```

---

### Copier/Coller un Workflow

* Utilisez **Ctrl+C / Cmd+C** dans l’éditeur pour copier un ou plusieurs nœuds.
* Utilisez **Ctrl+V / Cmd+V** dans un autre workflow pour les coller.
* n8n gère automatiquement les connexions et identifiants si compatibles.

---

### Importer un Workflow JSON

1. Créez un nouveau workflow.
2. Copiez le script JSON depuis une source externe.
3. Collez-le directement dans l’éditeur avec **Ctrl+V / Cmd+V**.
4. Reconnectez les identifiants requis.
5. Adaptez si besoin (prompts, IDs, etc.).
6. Sauvegardez.

---

### Boucler sur des données JSON

* Utilisez l’expression `{{ $json.body.block }}` dans un nœud **Item Lists** pour découper un tableau en items individuels.
* Chaque élément devient un item traitable indépendamment dans les nœuds suivants.

---

### Extraire des champs spécifiques d’un webhook

```text
{{ $json.body.ticker }}
{{ $json.body.tf }}
```

---

### Convertir une chaîne JSON en objet JSON

```javascript
// In a Code node
const parsedBody = JSON.parse($json.body);
return { json: parsedBody };
```

---

### Ajouter une donnée globale à tous les items (contexte partagé)

```javascript
// In a Code node
const results = [];
const eventName = $('Webhook').first().json.body.event.event_name;

for (const student of $json.body.students) {
  results.push({
    json: {
      ...student,
      eventName: eventName
    }
  });
}

return results;
```

Explication : Ceci combine des données contextuelles (`eventName`) extraites d’un autre nœud avec une liste d’éléments (étudiants), en les enrichissant individuellement. Utile après un découpage de tableau ou dans des boucles.

---

Avec ces derniers ajouts, votre **Ultimate N8n Automation Cheat Sheet** couvre désormais toutes les bases : import/export, boucles, conversions, intégration IA, enrichissement conditionnel, et services tiers.

```json
// Tools Agent (Default)
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

---

```json
// Conversational Agent
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

---

```json
// Memory-Enabled Agent
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Parsing AI Agent Output (String → JSON)

```javascript
// In a Code node
const outputStr = $json.output;

let parsedData;
try {
  parsedData = JSON.parse(outputStr);
  return { json: parsedData };
} catch (error) {
  return {
    json: {
      error: "Could not parse output as JSON",
      original: outputStr
    }
  };
}
```

---

### Generating JSON Example Before AI Agent

```javascript
const example = {
  data: [
    {
      Item1: "This is a test",
      Somedata: {
        Frog: 6,
        Cat: 7,
        Dog: 9
      }
    }
  ]
};

return { json: { example: JSON.stringify(example) } };
```

Dans l’AI Agent, utilisez :

```text
"prompt": "Use this structure: {{ $json.example }}"
```

---

### Using `$fromAI` (nouvelle méthode)

```text
{{ $fromAI.json.specificProperty }}
```

Permet de référencer directement des champs du résultat IA sans analyse manuelle.

---

### Exemple d'appel HTTP depuis l'AI Agent

```json
{
  "url": "https://api.example.com/endpoint",
  "method": "POST",
  "headers": {
    "Content-Type": "application/json"
  },
  "bodyParametersUi": {
    "parameter": [
      {
        "name": "ids",
        "value": "{{ [\"ID\"] }}"
      }
    ]
  }
}
```

---

### Préserver les données d’entrée (ID, etc.)

```javascript
const originalId = $node["PreviousNode"].first().json.id;
const aiOutput = $json.output;

return {
  json: {
    id: originalId,
    aiResult: aiOutput
  }
};
```

---

### Traitement de plusieurs items avec l'AI Agent

```javascript
// En Code node avant AI Agent
const allItems = $input.all().map(item => item.json);

return {
  json: {
    combinedData: allItems,
    prompt: "Process all these items at once: " + JSON.stringify(allItems)
  }
};
```

---

Ces extraits complètent le **Comprehensive Guide to JSON Snippets for N8n Automation**, en couvrant :

* La structure fondamentale des données
* L’utilisation avancée du module **AI Agent**
* La gestion des sorties IA (format string, fusion, ID)
* Les intégrations HTTP avec AI
* Le traitement de lots avec prompt dynamique
* L’usage sécurisé des expressions JSON en entrée

Ces pratiques assurent une automatisation fiable, performante et extensible dans vos workflows n8n.

```json
{
  "options": {
    "systemMessage": "You are a helpful assistant. Always respond in valid JSON format following this structure:\n\n{\n  \"category\": \"[Category of the request]\",\n  \"response\": \"[Your detailed response]\",\n  \"nextSteps\": [\"step1\", \"step2\", \"etc\"]\n}\n\nEnsure your entire response is valid JSON."
  }
}
```

Explication : Cette configuration fournit une instruction explicite dans le `systemMessage` pour forcer l'agent IA à répondre dans un format JSON structuré. Cela réduit les erreurs de parsing et facilite l'intégration avec les nœuds suivants.

---

### Expressions N8n pour accéder aux données JSON

* Accéder à une propriété simple :

  ```text
  {{ $json.property1 }}
  ```

* Accéder à une propriété imbriquée :

  ```text
  {{ $json.parent.child.property }}
  ```

* Accéder à un champ d’un nœud précédent spécifique :

  ```text
  {{ $node["NomDuNœud"].json.property }}
  ```

Ces expressions sont essentielles pour le mappage dynamique de données dans les champs des nœuds, les prompts IA, les conditions IF, et plus encore. Utilisez-les pour personnaliser vos workflows en fonction des données traitées.


