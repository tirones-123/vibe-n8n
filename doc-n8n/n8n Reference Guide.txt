n8n Automation Nodes Quick Reference

This quick reference provides JSON configuration snippets for common n8n nodes, categorized by function. Each snippet demonstrates how to use the node programmatically (as it would appear in a workflow's JSON). Use these examples as templates for creating workflows. (Note: Replace placeholder values ‚Äã‚Äãlike YOUR_API_KEY or YOUR_ID with actual values. Identifiers are referenced by name/ID after configuration in n8n.)

AI & LLM Integrations

OpenAI Chat Model (GPT-3.5/GPT-4): Uses OpenAI's Chat API to generate responses. You specify the model, prompts, and parameters like temperature. This node can take a system prompt and a user prompt to generate a response. For example, to use the GPT-3.5 Turbo model with a system role and a user message:

```json
{
  "name": "ChatGPT",
  "type": "n8n-nodes-langchain.lmChatOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "gpt-3.5-turbo",
    "temperature": 0.7,
    "maxTokens": 500,
    "systemPrompt": "You are a helpful assistant.",
    "userPrompt": "Hello! How can I automate tasks with n8n?"
  },
  "credentials": {
    "openAiApi": {
      "id": "YOUR_CRED_ID",
      "name": "OpenAI API"
    }
  }
}
```

Explanation: This configuration sets the OpenAI Chat node to use the GPT-3.5 model with a system message providing context and a user message. The response will be available as output from the node. Make sure you have configured an OpenAI API identifier named "OpenAI API," referenced in the identifiers. You can adjust the temperature for creativity and maxTokens for the response length.

OpenAI Text Completion: For GPT-3 completion models (like text-davinci-003), you can use the OpenAI node in completion mode. Provide a prompt and parameters. For example:

```json
{
  "name": "OpenAI Completion",
  "type": "n8n-nodes-langchain.openai",
  "typeVersion": 1,
  "parameters": {
    "model": "text-davinci-003",
    "prompt": "Summarize the following text: {{$json[\"content\"]}}",
    "temperature": 0.5,
    "maxTokens": 200
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela envoie une invite √† l‚Äôendpoint de compl√©tion d‚ÄôOpenAI pour r√©sumer un contenu provenant des donn√©es d‚Äôentr√©e. La syntaxe `{{$json["content"]}}` ins√®re les donn√©es du n≈ìud pr√©c√©dent. Le n≈ìud utilise les identifiants API OpenAI. Le r√©sultat appara√Æt dans le JSON de sortie du n≈ìud (champ result contenant le texte g√©n√©r√©).

Agents IA (avec outils) : n8n prend en charge des n≈ìuds d‚ÄôAgent avanc√©s qui permettent √† un mod√®le IA d‚Äôutiliser des outils (comme la recherche web, les calculatrices ou d‚Äôautres fonctions de n≈ìuds) pour accomplir des t√¢ches. Par exemple, l‚ÄôAgent avec fonctions OpenAI peut appeler des fonctions personnalis√©es, et l‚ÄôAgent ReAct utilise la strat√©gie ReAct pour d√©cider quel outil utiliser √† chaque √©tape. Voici un exemple simplifi√© de configuration de n≈ìud Agent IA utilisant un mod√®le OpenAI et un outil (par ex., un outil de recherche Google) :

```json
{
  "name": "Agent IA (ReAct)",
  "type": "n8n-nodes-langchain.agent",
  "typeVersion": 1,
  "parameters": {
    "agentType": "react",
    "model": "gpt-4",
    "memory": false,
    "tools": [
      {
        "name": "googleSearch",
        "input": "What is n8n?"
      }
    ]
  }
}
```

Explication : Cet agent est configur√© pour utiliser la strat√©gie ReAct avec GPT-4. Le tableau des outils correspond √† de v√©ritables n≈ìuds Tool connect√©s au n≈ìud Agent (par exemple, un n≈ìud de recherche Google dans le workflow). En pratique, vous ajoutez les outils via l‚Äôinterface graphique (ils deviennent des sous-n≈ìuds). L‚Äôagent d√©cide quand utiliser l‚Äôoutil. Par exemple, il pourrait utiliser l‚Äôoutil Google Search pour r√©cup√©rer des informations n√©cessaires √† une r√©ponse. Remarque : Le cluster de n≈ìuds Agent g√®re la logique ; assurez-vous d‚Äôavoir configur√© les bons outils et identifiants (comme les cl√©s API Google). Les agents peuvent aussi utiliser d'autres modes comme OpenAI Functions Agent, Plan-and-Execute Agent ou SQL Agent, chacun permettant √† l‚ÄôIA d‚Äôex√©cuter des t√¢ches complexes sp√©cifiques (par ex. appeler des fonctions d√©finies, d√©couper une t√¢che en sous-t√¢ches, ou ex√©cuter des requ√™tes SQL via des identifiants DB).

**Vecteurs et Bases de Donn√©es Vectorielles :** n8n propose des n≈ìuds pour g√©n√©rer des embeddings de texte avec des mod√®les (OpenAI, Cohere, Google PaLM, etc.) et pour les stocker/interroger dans des bases vectorielles (Pinecone, Weaviate, etc.). Par exemple, le n≈ìud OpenAI Embeddings peut prendre un texte et retourner un vecteur. L‚Äôutilisation est simple : vous sp√©cifiez le champ texte √† transformer et le mod√®le. La sortie est g√©n√©ralement un tableau de nombres repr√©sentant le vecteur. Ceux-ci peuvent √™tre utilis√©s avec un n≈ìud de type Vector Store (comme Pinecone) pour ins√©rer ou interroger des vecteurs. Exemple d‚Äôun n≈ìud OpenAI Embedding :

```json
{
  "name": "Text to Vector",
  "type": "n8n-nodes-langchain.embeddingsOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "text-embedding-ada-002",
    "text": "={{ $json[\"content\"] }}"
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela prend le champ "content" du JSON d‚Äôentr√©e et g√©n√®re un embedding √† 1536 dimensions √† l‚Äôaide du mod√®le ada d‚ÄôOpenAI. Ce vecteur est g√©n√©ralement envoy√© vers un stockage ou utilis√© dans une recherche par similarit√©. Pour le stockage, un n≈ìud Pinecone (ou autre DB vectorielle) peut √™tre utilis√© avec des op√©rations comme Ins√©rer un vecteur ou Interroger un vecteur (vous fournissez le nom de l‚Äôindex, les donn√©es du vecteur, et d‚Äô√©ventuels m√©tadonn√©es ou vecteurs de requ√™te). L‚Äôusage des bases vectorielles pouvant √™tre complexe, consultez la documentation du n≈ìud pour les param√®tres exacts. Le concept cl√© est que les n≈ìuds Embeddings convertissent du texte en vecteurs num√©riques, et les n≈ìuds Vector Store permettent de stocker et interroger ces vecteurs, ce qui permet des workflows comme la recherche s√©mantique ou la g√©n√©ration augment√©e par r√©cup√©ration.

**Int√©grations API & Webhooks**

**N≈ìud HTTP Request (APIs REST)** : C‚Äôest le n≈ìud universel pour appeler toute API RESTful. Vous pouvez configurer la m√©thode, l‚ÄôURL, les en-t√™tes, les param√®tres de requ√™te et le corps (y compris un corps JSON). Il prend en charge l‚Äôauthentification via des identifiants (OAuth2, jeton API, etc.) ou des en-t√™tes personnalis√©s. Voici un exemple de requ√™te GET avec param√®tres :

```json
{
  "name": "HTTP GET Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/data",
    "method": "GET",
    "responseFormat": "json",
    "queryParametersUi": {
      "parameter": [
        { "name": "q", "value": "search term" },
        { "name": "limit", "value": "10" }
      ]
    }
  }
}
```

Pour effectuer un POST avec un corps JSON, utilisez `jsonParameters: true` et fournissez l‚Äôobjet `bodyParametersJson` (ou les donn√©es de formulaire, etc.). Exemple de requ√™te POST :

```json
{
  "name": "HTTP POST Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/posts",
    "method": "POST",
    "responseFormat": "json",
    "jsonParameters": true,
    "options": {
      "bodyContentType": "json"
    },
    "bodyParametersJson": {
      "title": "Hello World",
      "content": "This is an example post via n8n."
    }
  },
  "credentials": {
    "httpBasicAuth": {
      "name": "Example API Auth"
    }
  }
}
```

Explication : Ce POST enverra une charge utile JSON avec `title` et `content`. On d√©finit `bodyContentType` sur JSON pour s'assurer de l‚Äôen-t√™te `Content-Type: application/json`. La section des identifiants (optionnelle) peut r√©f√©rencer une authentification HTTP Basic, OAuth2, ou un identifiant API selon les besoins de l‚ÄôAPI. Le n≈ìud HTTP est tr√®s flexible ‚Äì vous pouvez aussi l‚Äôutiliser pour GraphQL en envoyant une requ√™te GraphQL dans le corps ou en utilisant le n≈ìud d√©di√© GraphQL.

```json
{
  "name": "GraphQL Query",
  "type": "n8n-nodes-base.graphql",
  "typeVersion": 1,
  "parameters": {
    "endpoint": "https://api.spacex.land/graphql/",
    "query": "query Launches($limit:Int!) {\n launchesPast(limit: $limit) {\n mission_name\n launch_date_utc\n }\n}",
    "variables": "{ \"limit\": 3 }",
    "headerParametersUi": {
      "parameter": [
        { "name": "Authorization", "value": "Bearer YOUR_API_TOKEN" }
      ]
    }
  }
}
```

Explication : Cela interroge l‚ÄôAPI GraphQL de SpaceX pour les 3 derniers lancements. Un token Bearer est inclus dans les en-t√™tes (si l‚ÄôAPI n√©cessite une authentification). Le r√©sultat sera un JSON dans la sortie du n≈ìud. Le n≈ìud GraphQL envoie automatiquement la requ√™te au format JSON √† l‚Äôendpoint. Vous pouvez √©galement int√©grer des donn√©es dynamiques avec des expressions n8n dans la requ√™te ou les variables.

---

```json
{
  "name": "Webhook Trigger",
  "type": "n8n-nodes-base.webhook",
  "typeVersion": 1,
  "parameters": {
    "path": "incoming-data",
    "methods": ["POST"],
    "responseMode": "onReceived",
    "responseData": {
      "statusCode": 200,
      "body": "Webhook received successfully"
    }
  }
}
```

Explication : Cela cr√©e un webhook √† l‚ÄôURL `/webhook/incoming-data` (l‚ÄôURL compl√®te est visible dans l‚Äôinterface n8n). Il √©coute les requ√™tes POST. `responseMode: onReceived` signifie que n8n enverra imm√©diatement une r√©ponse d√®s que la requ√™te est re√ßue (sans attendre la fin du workflow), avec une r√©ponse statique 200 OK. Pour acc√©der aux donn√©es de la requ√™te, utilisez `{{$json["body"]["fieldName"]}}` dans les n≈ìuds suivants. Id√©al pour des services comme Stripe, GitHub ou des int√©grations personnalis√©es.

---

```json
{
  "name": "Webhook Response",
  "type": "n8n-nodes-base.respondToWebhook",
  "typeVersion": 1,
  "parameters": {
    "responseMode": "responseNode",
    "options": {
      "responseData": {
        "body": "{ \"success\": true, \"message\": \"Processed\" }",
        "headers": {
          "Content-Type": "application/json"
        },
        "statusCode": 200
      }
    }
  }
}
```

Explication : Placez ce n≈ìud √† l‚Äôendroit o√π vous souhaitez r√©pondre au webhook. Une fois ex√©cut√©, n8n envoie la r√©ponse sp√©cifi√©e et ne poursuit pas l‚Äôex√©cution des n≈ìuds suivants. Si vous souhaitez continuer le workflow apr√®s la r√©ponse, utilisez l‚Äôoption ‚Äúrespond and continue‚Äù. Utile pour les cas o√π une r√©ponse imm√©diate est n√©cessaire, suivie de traitements en arri√®re-plan.

```json
{
  "name": "Add Field",
  "type": "n8n-nodes-base.function",
  "typeVersion": 1,
  "parameters": {
    "functionCode": "for (const item of items) {\n item.json.newField = item.json.someField + 100;\n}\nreturn items;"
  }
}
```

Explication : Ce n≈ìud de code JavaScript parcourt chaque √©l√©ment d'entr√©e et ajoute un nouveau champ `newField` en lui assignant la valeur de `someField + 100`. Le n≈ìud retourne les items modifi√©s. Vous pouvez y effectuer des transformations plus complexes ou g√©n√©rer des donn√©es si aucun input n'est d√©fini.

---

```json
{
  "name": "Check Status",
  "type": "n8n-nodes-base.if",
  "typeVersion": 2,
  "parameters": {
    "conditions": {
      "conditions": [
        {
          "leftValue": "={{ $json[\"status\"] }}",
          "rightValue": "success",
          "operator": {
            "type": "string",
            "operation": "equals"
          }
        }
      ],
      "combinator": "and"
    }
  }
}
```

Explication : Ce n≈ìud IF v√©rifie si le champ `status` est √©gal √† `"success"`. Si oui, l‚Äô√©l√©ment est dirig√© vers la sortie vraie, sinon vers la fausse. Vous pouvez ajouter d‚Äôautres r√®gles et les combiner avec `and` ou `or`.

---

```json
{
  "name": "Route by Category",
  "type": "n8n-nodes-base.switch",
  "typeVersion": 1,
  "parameters": {
    "dataType": "string",
    "value1": "={{ $json[\"category\"] }}",
    "rules": {
      "rules": [
        { "operation": "equal", "value2": "support" },
        { "operation": "equal", "value2": "sales" }
      ]
    },
    "fallbackOutput": 2
  }
}
```

Explication : Ce n≈ìud Switch examine la valeur du champ `category`. Si elle vaut `"support"`, l‚Äô√©l√©ment va √† la sortie 0 ; si `"sales"`, √† la sortie 1 ; sinon, √† la sortie 2. Pratique pour diriger les donn√©es selon plusieurs cas.

---

```json
{
  "name": "Set Fields",
  "type": "n8n-nodes-base.set",
  "typeVersion": 3,
  "parameters": {
    "keepOnlySet": false,
    "values": {
      "number": [
        {
          "name": "year",
          "value": 2025
        }
      ],
      "string": [
        {
          "name": "statusMessage",
          "value": "Processed by n8n"
        }
      ]
    }
  }
}
```

Explication : Ce n≈ìud ajoute deux champs : un nombre `year` et une cha√Æne `statusMessage`. Comme `keepOnlySet` est √† false, les autres champs existants sont conserv√©s. C‚Äôest utile pour enrichir ou transformer les donn√©es avant de les envoyer ailleurs.

```json
{
  "name": "Merge on ID",
  "type": "n8n-nodes-base.merge",
  "typeVersion": 1,
  "parameters": {
    "mode": "mergeByKey",
    "propertyName": "id",
    "outputDataFrom": "both"
  }
}
```

Explication : Ce n≈ìud Merge combine deux flux de donn√©es en fonction du champ `id`. Il associe les √©l√©ments d'entr√©e 1 et 2 qui ont la m√™me valeur d'identifiant. Le champ `outputDataFrom: "both"` signifie que les donn√©es fusionn√©es incluront les champs des deux entr√©es. Utilisez-le pour regrouper des donn√©es s√©par√©es apr√®s traitement parall√®le.

---

```json
{
  "name": "Split Array",
  "type": "n8n-nodes-base.itemLists",
  "typeVersion": 1,
  "parameters": {
    "operation": "splitIntoItems",
    "property": "results"
  }
}
```

Explication : Ce n≈ìud transforme un champ `results` contenant un tableau en plusieurs √©l√©ments distincts, chacun contenant un seul √©l√©ment du tableau. Id√©al pour g√©rer les r√©ponses d‚ÄôAPI ou des champs de donn√©es group√©s.

---

```json
{
  "name": "Batch Loop",
  "type": "n8n-nodes-base.splitInBatches",
  "typeVersion": 1,
  "parameters": {
    "batchSize": 10
  }
}
```

Explication : Ce n≈ìud permet de traiter les √©l√©ments en lots de 10. Il envoie les premiers 10 √©l√©ments, attend un retour via son entr√©e secondaire pour envoyer le lot suivant. Cela permet un traitement it√©ratif (comme une boucle), utile pour limiter les appels API ou √©viter une surcharge. Le processus se r√©p√®te jusqu'√† √©puisement des √©l√©ments.

```json
{
  "name": "Stop on Condition",
  "type": "n8n-nodes-base.stopAndError",
  "typeVersion": 1,
  "parameters": {
    "message": "Terminating workflow due to business rule X"
  }
}
```

Explication : Ce n≈ìud arr√™te volontairement le workflow avec un message d'erreur personnalis√©. Il est utile apr√®s une condition (IF) pour bloquer l'ex√©cution si un crit√®re m√©tier n'est pas respect√©. L‚Äôex√©cution s‚Äôinterrompt et une erreur est g√©n√©r√©e.

---

```json
{
  "name": "Daily Schedule",
  "type": "n8n-nodes-base.cron",
  "typeVersion": 1,
  "parameters": {
    "triggerTimes": {
      "item": [
        { "hour": 9, "minute": 0 },
        { "hour": 17, "minute": 0 }
      ]
    }
  }
}
```

Explication : Ce n≈ìud d√©clenche le workflow chaque jour √† 9h00 et 17h00. Il s'agit d'un d√©clencheur planifi√© via le n≈ìud Cron. Aucun input n‚Äôest requis, et un √©l√©ment vide est envoy√© pour initier le workflow.

---

```json
{
  "name": "Email Trigger",
  "type": "n8n-nodes-base.emailReadImap",
  "typeVersion": 1,
  "parameters": {
    "mailbox": "INBOX",
    "postProcessAction": "read",
    "options": {
      "criteria": "UNSEEN"
    }
  },
  "credentials": {
    "imap": {
      "name": "My Email Account"
    }
  }
}
```

Explication : Ce n≈ìud surveille la bo√Æte de r√©ception IMAP et d√©clenche le workflow √† la r√©ception d‚Äôun email non lu, qu‚Äôil marque ensuite comme lu. Il permet d‚Äôautomatiser des r√©ponses ou extractions depuis des emails entrants.

---

```json
{
  "name": "Manual Trigger",
  "type": "n8n-nodes-base.manualTrigger",
  "typeVersion": 1,
  "parameters": {}
}
```

Explication : Ce n≈ìud d√©marre le workflow manuellement depuis l‚Äôinterface n8n (bouton "Ex√©cuter le workflow"). Il ne contient aucun param√®tre et g√©n√®re un √©l√©ment vide pour initier le traitement.

---

```json
{
  "name": "Run Sub-workflow",
  "type": "n8n-nodes-base.executeWorkflow",
  "typeVersion": 1,
  "parameters": {
    "workflowId": "123",
    "waitForCompletion": true,
    "inputs": {
      "inputData": "={{ $json[\"data\"] }}"
    }
  }
}
```

Explication : Ce n≈ìud appelle un sous-workflow (ID `123`) depuis un workflow principal. Il attend que l'ex√©cution soit termin√©e (`waitForCompletion: true`) et transmet une donn√©e d‚Äôentr√©e nomm√©e `inputData`. Le sous-workflow doit inclure un n≈ìud `Workflow Trigger` pour recevoir l‚Äôappel.

```json
{
  "name": "Send Slack Message",
  "type": "n8n-nodes-base.slack",
  "typeVersion": 1,
  "parameters": {
    "resource": "message",
    "operation": "send",
    "channel": "C01234567",
    "text": "Hello from n8n :tada:"
  },
  "credentials": {
    "slackApi": {
      "name": "Slack OAuth2"
    }
  }
}
```

Explication : Ce n≈ìud envoie le message "Hello from n8n üéâ" dans le canal Slack sp√©cifi√©. Le canal peut √™tre un ID ou un nom (assurez-vous que les autorisations n√©cessaires sont d√©finies dans l‚Äôapplication Slack). Ce n≈ìud utilise un identifiant Slack OAuth2.

---

```json
{
  "name": "Append to Sheet",
  "type": "n8n-nodes-base.googleSheets",
  "typeVersion": 4,
  "parameters": {
    "operation": "append",
    "spreadsheetId": "1A2b3C4D5E6FgHiJkLMnoPQrstu",
    "sheetName": "Sheet1",
    "dataMode": "autoMap",
    "options": {
      "valueInputMode": "USER_ENTERED"
    }
  },
  "credentials": {
    "googleSheetsOAuth2Api": {
      "name": "Google Sheets OAuth2"
    }
  }
}
```

Explication : Ce n≈ìud ajoute une ligne √† une feuille Google Sheets nomm√©e "Sheet1". Il utilise le mode `autoMap` pour faire correspondre automatiquement les champs d'entr√©e avec les colonnes. Le mode `USER_ENTERED` fait en sorte que les formules soient recalcul√©es comme si un utilisateur avait saisi les donn√©es.

---

```json
{
  "name": "Query Notion DB",
  "type": "n8n-nodes-base.notion",
  "typeVersion": 2,
  "parameters": {
    "resource": "databasePage",
    "operation": "getAll",
    "databaseId": "YOUR_NOTION_DATABASE_ID",
    "options": {
      "filter": {
        "singleCondition": {
          "key": "Email|email",
          "condition": "equals",
          "emailValue": "={{ $json[\"email\"] }}"
        }
      }
    }
  },
  "credentials": {
    "notionApi": {
      "name": "Notion API"
    }
  }
}
```

Explication : Ce n≈ìud interroge une base de donn√©es Notion et renvoie les pages dont le champ "Email" correspond √† la valeur provenant des donn√©es entrantes. Il utilise l‚Äôop√©ration `getAll` sur la ressource `databasePage` avec un filtre conditionnel. Un identifiant d‚ÄôAPI Notion est requis.

```json
{
  "name": "Create GitHub Issue",
  "type": "n8n-nodes-base.github",
  "typeVersion": 1,
  "parameters": {
    "resource": "issue",
    "operation": "create",
    "owner": "octocat",
    "repository": "Hello-World",
    "title": "Automated Issue from n8n",
    "body": "This issue was created by an n8n workflow."
  },
  "credentials": {
    "githubApi": {
      "name": "GitHub personal access token"
    }
  }
}
```

Explication : Ce n≈ìud cr√©e un ticket GitHub dans le d√©p√¥t `octocat/Hello-World`. Il utilise un token personnel GitHub configur√© dans les identifiants. Vous pouvez aussi utiliser d'autres op√©rations sur les issues, les commits, les pull requests, etc.

---

```json
{
  "name": "MySQL Query",
  "type": "n8n-nodes-base.mySql",
  "typeVersion": 2,
  "parameters": {
    "operation": "executeQuery",
    "query": "SELECT * FROM users WHERE id = {{ $json[\"user_id\"] }}",
    "additionalFields": {}
  },
  "credentials": {
    "mySql": {
      "name": "My MySQL DB"
    }
  }
}
```

Explication : Ce n≈ìud ex√©cute une requ√™te SQL personnalis√©e dans une base MySQL en injectant dynamiquement un `user_id`. Chaque ligne du r√©sultat devient un item JSON. √âvitez les injections SQL en contr√¥lant les donn√©es ins√©r√©es dans les expressions.

---

R√©sum√© des autres int√©grations :

* **Notion (create/update/query pages)** : Tr√®s utile pour automatiser des tableaux de bord, notes, suivis de t√¢ches.
* **Slack (messagerie, alertes)** : Envoi de messages, notifications automatiques, support de blocks JSON.
* **Google Sheets** : Lecture et √©criture de feuilles, synchronisation de donn√©es, export automatis√©.
* **GitHub** : Cr√©ation de tickets, gestion des pull requests, int√©gration DevOps.
* **MySQL/PostgreSQL** : Int√©gration directe avec vos bases de donn√©es m√©tiers pour lecture/√©criture.
* **Autres services populaires :**

  * **AWS S3** : Upload/download de fichiers.
  * **Google Drive** : Gestion de fichiers cloud.
  * **Twilio** : SMS, WhatsApp.
  * **Stripe** : Paiements, √©v√©nements.
  * **Jira, Trello, Asana** : Gestion de t√¢ches.
  * **HubSpot, Salesforce** : CRM automatis√©.
  * **Email SMTP / SendGrid** : Envoi d‚Äôemails transactionnels.
  * **Webhook/HTTP** : Int√©gration d‚ÄôAPI ou de services personnalis√©s.
  * **CSV/XML** : Lecture/√©criture de formats structur√©s.

Tous ces n≈ìuds suivent le sch√©ma : `resource` ‚Üí `operation` ‚Üí `param√®tres`. Cr√©ez-les dans l‚Äô√©diteur n8n, puis exportez en JSON pour les r√©utiliser ou les automatiser.

**Conseils d'utilisation :**

* **Expressions :**
  Les expressions comme `={{ $json["..."] }}` servent √† r√©cup√©rer des donn√©es d‚Äôun n≈ìud pr√©c√©dent. Elles doivent √™tre entre doubles accolades dans une cha√Æne JSON. n8n les √©value √† l‚Äôex√©cution. Vous pouvez aussi utiliser `$node["NomDuN≈ìud"].json["champ"]` pour pointer vers un champ pr√©cis d‚Äôun autre n≈ìud, ou `$items()` pour acc√©der √† plusieurs √©l√©ments.

* **Identifiants (Credentials) :**
  La section `"credentials"` dans chaque n≈ìud lie le n≈ìud √† un identifiant stock√©. Elle peut √™tre de la forme `{ "id": "some-id", "name": "Credential Name" }` ou juste `"name"`. Lors de la cr√©ation de workflows via l‚ÄôAPI, le nom suffit s‚Äôil est unique. Assurez-vous que l‚Äôidentifiant est bien configur√© dans n8n avant usage.

* **ID de n≈ìud et position :**
  Des champs comme `id` et `position` peuvent appara√Ætre dans des exports. Ils ne sont pas n√©cessaires pour un guide comme celui-ci, mais sont utilis√©s par l‚Äôinterface graphique pour positionner les n≈ìuds. On peut les omettre si on se concentre uniquement sur la configuration fonctionnelle.

---

**Connexion des n≈ìuds :**

Dans le JSON d‚Äôun workflow complet, la section `"connections"` relie les sorties des n≈ìuds aux entr√©es d‚Äôautres n≈ìuds. Exemple pour une cha√Æne Cron ‚Üí GraphQL ‚Üí Function ‚Üí Slack :

```json
"connections": {
  "Cron": {
    "main": [
      [
        {
          "node": "GraphQL",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "GraphQL": {
    "main": [
      [
        {
          "node": "Summarize",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "Summarize": {
    "main": [
      [
        {
          "node": "Slack",
          "type": "main",
          "index": 0
        }
      ]
    ]
  }
}
```

Cela indique que la sortie du n≈ìud `"Cron"` est connect√©e √† l‚Äôentr√©e du n≈ìud `"GraphQL"`, et ainsi de suite. Si vous cr√©ez un workflow via l‚ÄôAPI, vous devez construire manuellement cette structure.

---

**Tests et it√©ration :**
Commencez par un workflow simple (`Manual Trigger ‚Üí un seul n≈ìud ‚Üí sortie`) pour valider votre structure JSON, puis ajoutez progressivement des √©tapes. Vous pouvez importer un JSON dans n8n via **Workflow ‚Üí Import from JSON** pour le visualiser et le tester.

---

**Conclusion :**
Cette fiche a couvert les principales cat√©gories et les n≈ìuds les plus populaires (IA, webhooks, int√©grations, traitement de donn√©es). En combinant ces exemples, vous pouvez automatiser une grande vari√©t√© de processus dans n8n. Bonne automatisation !


```json
[
  {
    "json": {
      "property1": "value1",
      "property2": "value2"
    },
    "binary": {}
  },
  {
    "json": {
      "property1": "anotherValue1",
      "property2": "anotherValue2"
    },
    "binary": {}
  }
]
```

Explication : Dans n8n, les donn√©es circulent entre les n≈ìuds sous forme d‚Äôun tableau d‚Äôobjets appel√©s **items**. Chaque item poss√®de une cl√© `json` (donn√©es structur√©es) et une cl√© `binary` (fichiers, le cas √©ch√©ant). Les n≈ìuds traitent chaque item individuellement, ce qui permet un traitement parall√®le.

---

### Acc√®s aux donn√©es avec les expressions

* `{{ $json.property1 }}` ‚Äì acc√®de √† un champ simple.
* `{{ $json.parent.child.property }}` ‚Äì acc√®de √† une propri√©t√© imbriqu√©e.
* `{{ $node["NomDuN≈ìud"].json.property }}` ‚Äì acc√®de aux donn√©es d‚Äôun autre n≈ìud sp√©cifique.

---

### Exemple ‚Äì n≈ìud Set en mode de mappage manuel :

```json
{
  "newField": "{{ $json.existingField }}",
  "combinedField": "{{ $json.firstName }} {{ $json.lastName }}",
  "staticField": "This is a static value"
}
```

Explication : Ce n≈ìud cr√©e trois champs :

* `newField` reprend la valeur d‚Äôun champ existant.
* `combinedField` combine deux champs.
* `staticField` ins√®re une valeur fixe.

---

### Exemple ‚Äì mode JSON Output du n≈ìud Set :

```json
{
  "mode": "jsonOutput",
  "jsonOutput": {
    "newField": "{{ $json.existingField }}",
    "processedData": {
      "id": "{{ $json.id }}",
      "timestamp": "{{ $now }}"
    }
  }
}
```

Explication : Cette configuration produit une structure JSON personnalis√©e contenant un champ `newField` et un objet imbriqu√© `processedData` avec un ID et un horodatage dynamique.

---

### Prise en charge de la notation par point (dot notation)

```json
{
  "number": {
    "one": 20
  }
}
```

* Si vous utilisez `"name": "number.one"` avec une valeur `20`, le champ sera interpr√©t√© comme `number.one` ‚Üí `number: { one: 20 }`.
* Pour d√©sactiver cela, ajoutez l‚Äôoption `"supportDotNotation": false`.

---

### N≈ìud Code ‚Äì transformations programmatiques

Le n≈ìud **Code** (anciennement Function) permet de manipuler les donn√©es avec du **JavaScript** (ou Python, si activ√©). Il peut g√©n√©rer des donn√©es ou transformer les items entrants. Deux modes principaux :

* **Item-wise (par √©l√©ment)** ‚Äì boucle automatique sur chaque item
* **Manual/Batch** ‚Äì contr√¥le complet sur `items[]` et retour group√©

Exemple simple en JavaScript :

```javascript
for (const item of items) {
  item.json.processed = true;
  item.json.fullName = `${item.json.firstName} ${item.json.lastName}`;
}
return items;
```

Explication : Ce code ajoute un champ `processed` √† `true` et g√©n√®re un champ `fullName` √† partir des donn√©es existantes.

---

Cette section compl√®te la fiche ultime n8n avec une compr√©hension approfondie du format de donn√©es, des expressions, du n≈ìud Set, et de l‚Äôutilisation avanc√©e du n≈ìud Code.

```javascript
// Run Once for All Items
const newItems = [];

const inputData = $input.all().json;

for (const item of inputData) {
  newItems.push({
    json: {
      modifiedData: item.originalData,
      timestamp: new Date().toISOString()
    }
  });
}

return newItems;
```

Explication : Ce script traite tous les items en une seule fois. Il acc√®de √† tous les objets d'entr√©e avec `$input.all().json`, les transforme, et retourne un nouveau tableau.

---

```javascript
// Run Once for Each Item
const item = $json;

item.processed = true;
item.modifiedAt = new Date().toISOString();

return { json: item };
```

Explication : Ce script modifie chaque item ind√©pendamment, ajoutant deux champs : `processed` et `modifiedAt`. Il retourne l‚Äôitem enrichi.

---

```javascript
// Splitting JSON into Separate Items
let results = [];

for (const item of $('Webhook').all()) {
  const students = item.json.body.students;
  for (studentKey of Object.keys(students)) {
    results.push({
      json: students[studentKey]
    });
  }
}

return results;
```

Explication : Ce code prend une r√©ponse JSON avec des donn√©es imbriqu√©es (ici des √©tudiants) et les convertit en items individuels. Utile pour traiter chaque √©l√©ment s√©par√©ment dans les workflows.

---

### Syntaxe d'expressions de base

* `{{ $json.city }}` : Acc√®de √† la propri√©t√© `city` d‚Äôun JSON entrant, typiquement d‚Äôun webhook.
* `{{ $node["NodeName"].json.property }}` : R√©cup√®re une valeur d‚Äôun n≈ìud sp√©cifique pr√©c√©dent.

---

### Exemple de configuration d‚Äôun AI Agent (LangChain)

**Agent avec outils :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

**Agent conversationnel :**

```json
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

**Agent avec m√©moire persistante :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Export et import de workflows

Les workflows n8n sont sauvegard√©s au format JSON. Cela permet :

* de les importer/exporter facilement,
* de les versionner,
* de les partager ou les d√©ployer automatiquement via API ou CLI.

Pour importer : **Menu Workflow ‚Üí Import from JSON**.
Pour exporter : **Menu Workflow ‚Üí Export ‚Üí Copy JSON**.

C‚Äôest id√©al pour collaborer, sauvegarder ou migrer vos automatisations.

```json
// XML to JSON Converter
{
  "operation": "convert",
  "source": "xml",
  "target": "json",
  "data": "{{ $json.xmlData }}"
}
```

```json
// CSV to JSON Converter
{
  "operation": "convert",
  "source": "csv",
  "target": "json",
  "data": "{{ $json.csvData }}"
}
```

```json
// Google Sheets Integration - Append or Update
{
  "operation": "appendOrUpdate",
  "sheetId": "YOUR_SHEET_ID",
  "range": "A:Z",
  "data": "{{ $json.rowData }}"
}
```

```json
// OpenAI Node to Generate Structured JSON
{
  "model": "gpt-4",
  "prompt": "Generate a JSON object with the following structure: {{ $json.structure }}",
  "temperature": 0.2,
  "output": "json"
}
```

---

### Copier/Coller un Workflow

* Utilisez **Ctrl+C / Cmd+C** dans l‚Äô√©diteur pour copier un ou plusieurs n≈ìuds.
* Utilisez **Ctrl+V / Cmd+V** dans un autre workflow pour les coller.
* n8n g√®re automatiquement les connexions et identifiants si compatibles.

---

### Importer un Workflow JSON

1. Cr√©ez un nouveau workflow.
2. Copiez le script JSON depuis une source externe.
3. Collez-le directement dans l‚Äô√©diteur avec **Ctrl+V / Cmd+V**.
4. Reconnectez les identifiants requis.
5. Adaptez si besoin (prompts, IDs, etc.).
6. Sauvegardez.

---

### Boucler sur des donn√©es JSON

* Utilisez l‚Äôexpression `{{ $json.body.block }}` dans un n≈ìud **Item Lists** pour d√©couper un tableau en items individuels.
* Chaque √©l√©ment devient un item traitable ind√©pendamment dans les n≈ìuds suivants.

---

### Extraire des champs sp√©cifiques d‚Äôun webhook

```text
{{ $json.body.ticker }}
{{ $json.body.tf }}
```

---

### Convertir une cha√Æne JSON en objet JSON

```javascript
// In a Code node
const parsedBody = JSON.parse($json.body);
return { json: parsedBody };
```

---

### Ajouter une donn√©e globale √† tous les items (contexte partag√©)

```javascript
// In a Code node
const results = [];
const eventName = $('Webhook').first().json.body.event.event_name;

for (const student of $json.body.students) {
  results.push({
    json: {
      ...student,
      eventName: eventName
    }
  });
}

return results;
```

Explication : Ceci combine des donn√©es contextuelles (`eventName`) extraites d‚Äôun autre n≈ìud avec une liste d‚Äô√©l√©ments (√©tudiants), en les enrichissant individuellement. Utile apr√®s un d√©coupage de tableau ou dans des boucles.

---

Avec ces derniers ajouts, votre **Ultimate N8n Automation Cheat Sheet** couvre d√©sormais toutes les bases : import/export, boucles, conversions, int√©gration IA, enrichissement conditionnel, et services tiers.

```json
// Tools Agent (Default)
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

---

```json
// Conversational Agent
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

---

```json
// Memory-Enabled Agent
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Parsing AI Agent Output (String ‚Üí JSON)

```javascript
// In a Code node
const outputStr = $json.output;

let parsedData;
try {
  parsedData = JSON.parse(outputStr);
  return { json: parsedData };
} catch (error) {
  return {
    json: {
      error: "Could not parse output as JSON",
      original: outputStr
    }
  };
}
```

---

### Generating JSON Example Before AI Agent

```javascript
const example = {
  data: [
    {
      Item1: "This is a test",
      Somedata: {
        Frog: 6,
        Cat: 7,
        Dog: 9
      }
    }
  ]
};

return { json: { example: JSON.stringify(example) } };
```

Dans l‚ÄôAI Agent, utilisez :

```text
"prompt": "Use this structure: {{ $json.example }}"
```

---

### Using `$fromAI` (nouvelle m√©thode)

```text
{{ $fromAI.json.specificProperty }}
```

Permet de r√©f√©rencer directement des champs du r√©sultat IA sans analyse manuelle.

---

### Exemple d'appel HTTP depuis l'AI Agent

```json
{
  "url": "https://api.example.com/endpoint",
  "method": "POST",
  "headers": {
    "Content-Type": "application/json"
  },
  "bodyParametersUi": {
    "parameter": [
      {
        "name": "ids",
        "value": "{{ [\"ID\"] }}"
      }
    ]
  }
}
```

---

### Pr√©server les donn√©es d‚Äôentr√©e (ID, etc.)

```javascript
const originalId = $node["PreviousNode"].first().json.id;
const aiOutput = $json.output;

return {
  json: {
    id: originalId,
    aiResult: aiOutput
  }
};
```

---

### Traitement de plusieurs items avec l'AI Agent

```javascript
// En Code node avant AI Agent
const allItems = $input.all().map(item => item.json);

return {
  json: {
    combinedData: allItems,
    prompt: "Process all these items at once: " + JSON.stringify(allItems)
  }
};
```

---

Ces extraits compl√®tent le **Comprehensive Guide to JSON Snippets for N8n Automation**, en couvrant :

* La structure fondamentale des donn√©es
* L‚Äôutilisation avanc√©e du module **AI Agent**
* La gestion des sorties IA (format string, fusion, ID)
* Les int√©grations HTTP avec AI
* Le traitement de lots avec prompt dynamique
* L‚Äôusage s√©curis√© des expressions JSON en entr√©e

Ces pratiques assurent une automatisation fiable, performante et extensible dans vos workflows n8n.

```json
{
  "options": {
    "systemMessage": "You are a helpful assistant. Always respond in valid JSON format following this structure:\n\n{\n  \"category\": \"[Category of the request]\",\n  \"response\": \"[Your detailed response]\",\n  \"nextSteps\": [\"step1\", \"step2\", \"etc\"]\n}\n\nEnsure your entire response is valid JSON."
  }
}
```

Explication : Cette configuration fournit une instruction explicite dans le `systemMessage` pour forcer l'agent IA √† r√©pondre dans un format JSON structur√©. Cela r√©duit les erreurs de parsing et facilite l'int√©gration avec les n≈ìuds suivants.

---

### Expressions N8n pour acc√©der aux donn√©es JSON

* Acc√©der √† une propri√©t√© simple :

  ```text
  {{ $json.property1 }}
  ```

* Acc√©der √† une propri√©t√© imbriqu√©e :

  ```text
  {{ $json.parent.child.property }}
  ```

* Acc√©der √† un champ d‚Äôun n≈ìud pr√©c√©dent sp√©cifique :

  ```text
  {{ $node["NomDuN≈ìud"].json.property }}
  ```

Ces expressions sont essentielles pour le mappage dynamique de donn√©es dans les champs des n≈ìuds, les prompts IA, les conditions IF, et plus encore. Utilisez-les pour personnaliser vos workflows en fonction des donn√©es trait√©es.


