================================================================
FICHE MÉMO COMPLÈTE : DÉFINITIONS JSON DES NŒUDS n8n, TOUS LES OUTILS, NUANCES D’INTÉGRATION & MANIPULATION DE L’AGENT IA
=========================================================================================================================

Ce document combine une vue d’ensemble générale des structures JSON des nœuds n8n avec des sections détaillées sur chaque outil rencontré — des déclencheurs de chat et post-it aux intégrations avec Pinecone, Airtable, PostgreSQL, Google Docs, Google Calendar, Telegram, les API HTTP, SerpAPI, les outils de workflow, et plus encore. Il couvre également les bonnes pratiques pour manipuler le module Agent IA et aborde les problèmes courants de valeurs de propriétés lors de la génération de JSON via des LLM.

────────────────────────────────────────────────────────────

1. STRUCTURE JSON GÉNÉRALE DES NŒUDS n8n
   ────────────────────────────────────────────────────────────
   Vue d’ensemble :
   • Chaque nœud est défini comme un objet JSON avec un ensemble commun de clés.
   • Ces clés s’appliquent à tous les types de nœuds, qu’ils gèrent les déclencheurs, le traitement des données, la documentation ou les intégrations externes.

Champs principaux de haut niveau :
– **id :** Identifiant unique (généralement un UUID). Doit être unique dans un workflow.
– **name :** Étiquette lisible par l’humain (ex. : "Quand un message de chat est reçu", "Airtable - Mettre à jour les enregistrements").
– **type :** Définit la fonctionnalité du nœud ; exemples :
• `"@n8n/n8n-nodes-langchain.chatTrigger"` pour les déclencheurs de chat.
• `"n8n-nodes-base.stickyNote"` pour les annotations.
• D’autres outils utilisent des identifiants de type spécifiques.
– **typeVersion :** Version du schéma (souvent 1, 1.1, 1.7, etc.). Les versions supérieures peuvent prendre en charge des fonctionnalités supplémentaires.
– **position :** Un tableau `[x, y]` déterminant le placement du nœud sur le canevas visuel.
– **parameters :** Objet imbriqué contenant les configurations spécifiques du nœud (actions, identifiants, texte d’interface utilisateur, etc.).

Bonnes pratiques :
• Utiliser des noms descriptifs et des positions logiques pour maintenir un workflow organisé.
• Exploiter le langage d'expression de n8n (ex. : `={{ $json["field"] }}`) pour du contenu dynamique.
• Valider votre JSON (ex. : avec un linter) pour détecter les problèmes de valeurs de propriétés comme les guillemets incorrects, les virgules finales, ou les erreurs de type.

────────────────────────────────────────────────────────────
2\. NŒUDS DE DÉCLENCHEMENT DE CHAT (@n8n/n8n-nodes-langchain.chatTrigger)
────────────────────────────────────────────────────────────
Objectif :
• Écouter les messages entrants via des webhooks ou des widgets de chat intégrés.
• Servir de point d’entrée pour les workflows basés sur la conversation.

Paramètres clés :
• **webhookId :** Identifiant unique reliant le nœud à son point de terminaison webhook.
• **mode :** Typiquement `"webhook"` pour indiquer le mode de réception des événements.
• **public (booléen) :** Détermine si le point de terminaison de chat est accessible publiquement. À utiliser avec des `allowedOrigins` sécurisés.
• **initialMessages :** Texte de salutation ou d’instruction prédéfini (prend en charge Markdown et les expressions dynamiques).
• **options :** Paramètres avancés incluant :
– **responseMode :** Mode d’envoi des réponses (ex. : `"responseNode"`).
– **allowedOrigins :** Domaines autorisés à accéder au point de terminaison de chat.
– **title/subtitle :** Texte personnalisé de l’interface utilisateur.
– **allowFileUploads :** Activer/désactiver le téléversement de fichiers.
– **loadPreviousSession :** Gère la persistance de session (ex. : `"memory"`).

Nuances :
• S’assurer que chaque webhookId de déclencheur de chat est unique.
• Les expressions dynamiques dans initialMessages permettent une personnalisation à l’exécution.
• Les différentes versions (1 vs 1.1) peuvent offrir des paramètres variables.

────────────────────────────────────────────────────────────
3\. NŒUDS POST-IT (n8n-nodes-base.stickyNote)
────────────────────────────────────────────────────────────
Objectif :
• Fournir une documentation interne au workflow, des annotations ou des rappels.
• N’affectent pas le flux de données ; usage purement informatif.

Paramètres clés :
• **content :** Texte affiché (prend en charge Markdown pour titres, listes, blocs de code, liens, images).
• **width & height :** Définissent les dimensions visuelles sur le canevas.
• **color (optionnel) :** Code numérique pour attribuer une couleur d’arrière-plan à des fins visuelles.

Conseils d’utilisation :
• Placer les post-its à proximité des nœuds concernés pour ajouter du contexte.
• Utiliser une mise en forme Markdown claire et concise.
• Mettre à jour les notes régulièrement à mesure que les workflows évoluent.

────────────────────────────────────────────────────────────
4\. MODULE AGENT IA (n8n-nodes-langchain.agent)
────────────────────────────────────────────────────────────
Objectif :
• Traiter les entrées utilisateur et générer des réponses interactives contextuelles.
• Invoquer dynamiquement d’autres outils selon le contexte de conversation et la mémoire.

Paramètres clés :
• **text :** Entrée principale, typiquement définie dynamiquement (ex. : `={{ $json.chatInput }}`).
• **options :** Contient un `systemMessage` détaillé qui :
– Définit le rôle et le comportement de l’agent IA.
– Fournit des directives pour la gestion de la mémoire et l’appel d’outils.
– Peut inclure des instructions supplémentaires pour le format des réponses.
• **promptType :** Généralement `"define"`, appliquant les règles du message système.

Intégration & mémoire :
• Se connecte à des sous-fonctions via des ports comme `ai_tool`, `ai_memory`, et `ai_languageModel`.
• Souvent associé à des nœuds mémoire (ex. : `memoryBufferWindow`) pour fournir l’historique des conversations.

Nuances :
• Rédiger soigneusement le systemMessage pour gérer divers scénarios.
• Valider le JSON de sortie pour détecter les problèmes de valeurs de propriétés (voir Section 6).
• Expérimenter avec différents modèles (ex. : "gpt-4o" vs "gpt-4o-mini") pour un équilibre performance/coût.

## Exemples de snippets :

*Configuration minimale d’un agent IA :*

```json
{
  "id": "agent-1",
  "name": "Agent IA pour Chat",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [100, 100],
  "parameters": {
      "text": "={{ $json.chatInput }}",
      "options": { "systemMessage": "=Vous êtes un assistant utile." },
      "promptType": "define"
  },
  "typeVersion": 1.7
}
```

---

*Agent IA avec intégration calendrier :*

```json
{
  "id": "agent-2",
  "name": "Agent IA Calendrier",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [200, 200],
  "parameters": {
      "text": "={{ $json.chatInput }}",
      "options": { "systemMessage": "=Vous êtes un assistant Google Calendar. Demandez les détails de l’événement avant de le créer." },
      "promptType": "define"
  },
  "typeVersion": 1.7
}
```

---

*Agent IA avec mémoire intégrée :*

```json
{
  "id": "agent-3",
  "name": "Agent IA avec Mémoire",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [300, 300],
  "parameters": {
      "text": "={{ $json.chatInput }}",
      "options": { "systemMessage": "=Utilisez la mémoire à long terme pour fournir des réponses contextuelles." },
      "promptType": "define"
  },
  "typeVersion": 1.7
}
```

────────────────────────────────────────────────────────────
5\. NŒUDS DE MÉMOIRE TAMPON (n8n-nodes-langchain.memoryBufferWindow)
────────────────────────────────────────────────────────────
Objectif :
• Gérer l’historique temporaire de conversation pour l’agent IA.

Paramètres clés :
• **sessionKey :** Identifiant pour la session mémoire (peut être dynamique).
• **contextWindowLength :** Nombre de messages à conserver dans la fenêtre de contexte.

Conseils d’utilisation :
• Ajuster contextWindowLength en fonction de la complexité de la conversation.
• Utiliser des clés de session cohérentes pour maintenir la continuité de la mémoire.

────────────────────────────────────────────────────────────
6\. OUTILS D’INTÉGRATION ET LEURS OPÉRATIONS
────────────────────────────────────────────────────────────
Cette section détaille chaque outil externe rencontré et ses spécificités.

## **6.1. PINECONE**

Objectif :
• Interface avec la base de données vectorielle de Pinecone pour indexer, insérer et interroger des vecteurs.

Opérations clés :
• Création/Mise à jour d’index – Définir les noms d’index, dimensions, et métriques.
• Insertion de vecteurs – Faire correspondre les champs JSON aux données vectorielles ; le schéma doit correspondre à l’index.
• Requête de vecteurs – Récupérer des vecteurs similaires selon les paramètres de requête.

Nuances :
• S’assurer que les identifiants API et les correspondances de champs sont exacts.
• Utiliser des noms de nœuds descriptifs (ex. : "Pinecone - Insérer des vecteurs").

## **6.2. AIRTABLE**

Objectif :
• Gérer des enregistrements dans des bases Airtable.

Opérations clés :
• Lecture, création, mise à jour, et suppression d’enregistrements.
• Mappage des champs : les clés JSON doivent correspondre exactement aux noms de colonnes d’Airtable.

Nuances :
• Sécuriser les clés API via les identifiants.
• Utiliser des expressions dynamiques pour gérer les données des enregistrements.

## **6.3. POSTGRESQL**

Objectif :
• Exécuter des requêtes SQL pour manipuler des données.

Opérations clés :
• Requêtes SELECT, INSERT, UPDATE, DELETE.
• Utiliser des requêtes paramétrées pour éviter les injections SQL.

Nuances :
• S’assurer que la syntaxe SQL est valide et que les valeurs dynamiques sont correctement insérées.
• Utiliser des nœuds comme postgresTool pour les tâches de manipulation JSON.

## **6.4. GOOGLE DOCS**

Objectif :
• Récupérer ou mettre à jour des Google Docs pour stocker de la mémoire à long terme ou des notes.

Opérations clés :
• “get” pour la récupération et “update” pour l’insertion de contenu.
• Utiliser actionsUi (dans googleDocsTool) pour définir les charges utiles JSON pour les opérations.

Nuances :
• Lier les bons identifiants OAuth.
• Mapper correctement les champs dynamiques (ex. : dates, contenu mémoire).

## **6.5. GOOGLE CALENDAR**

Objectif :
• Récupérer ou créer des événements dans Google Calendar.

Opérations clés :
• Récupérer des événements : utiliser des filtres de plage de dates avec des expressions dynamiques.
• Créer des événements : spécifier le début, la fin, le résumé, la description, et des champs supplémentaires (participants, données de conférence).

Nuances :
• Valider les formats de date (AAAA-MM-JJ HH\:mm\:ss).
• S’assurer que le mappage des champs calendrier correspond à l’API Google Calendar.

## **6.6. TELEGRAM**

Objectif :
• Gérer la messagerie via Telegram.

Types de nœuds clés :
• telegramTrigger : pour recevoir des messages.
• telegram : pour envoyer des réponses textuelles.
• telegramTool : pour envoyer des fichiers/documents.

Paramètres clés :
• webhookId (pour les déclencheurs), chatId, text, file (URL), et additionalFields (ex. : parse\_mode).

Nuances :
• Utiliser des expressions dynamiques pour récupérer les IDs de chat.
• Tester avec des identifiants de bac à sable si possible.

## **6.7. REQUÊTE HTTP**

Objectif :
• Effectuer des appels API HTTP génériques (ex. : génération d’image DALL-E).

Paramètres clés :
• url, method, sendBody, sendHeaders.
• authentication : identifiants prédéfinis ou génériques.

Nuances :
• S’assurer que les corps JSON sont valides.
• Utiliser ce nœud pour appeler des APIs externes comme DALL-E en définissant le modèle dans la charge utile.

## **6.8. OUTIL SERPAPI**

Objectif :
• Interroger les données de moteurs de recherche via SerpAPI.

Paramètres clés :
• options : paramètres supplémentaires de requête.

Nuances :
• Lier les bons identifiants SerpAPI.
• Formuler des requêtes de recherche dynamiques basées sur l’entrée utilisateur.

## **6.9. OUTIL DE WORKFLOW**

Objectif :
• Déclencher ou exécuter des workflows distincts (ex. : création de tâche).

Paramètres clés :
• name, workflowId, schemaType, et inputSchema.

Nuances :
• Valider que le schéma JSON d’entrée correspond au workflow cible.
• À utiliser pour automatiser des sous-workflows.

## **6.10. OUTIL GMAIL**

Objectif :
• Envoyer des emails via Gmail.

Paramètres clés :
• sendTo, subject, message, additionalFields.

Nuances :
• Personnaliser les emails avec des expressions dynamiques.
• S’assurer que les identifiants OAuth sont correctement définis.

## **6.11. SUPABASE**

Objectif :
• Interagir avec des bases de données Supabase.

Paramètres clés :
• tableId, fieldsUi (mappage des données JSON vers les champs de table).

Nuances :
• S’assurer que le schéma de données correspond à votre table Supabase.
• Sécuriser les clés API via les identifiants.

## **6.12. NŒUDS GÉNÉRIQUES ET AUXILIAIRES**

Objectif :
• Gérer des opérations générales telles que les affectations de valeurs, la fusion de données, la division de sorties, les conditionnels, et le déclenchement de sous-workflows.

Exemples clés :
• Nœuds Set : pour assigner des valeurs (ex. : invites système).
• Merge, Aggregate, Split Out : pour l’orchestration de données.
• Nœuds If : pour la logique conditionnelle.
• Execute Workflow Trigger & Respond To Webhook : pour le flux de contrôle.

Nuances :
• Garder les configurations propres et valider les expressions dynamiques.

────────────────────────────────────────────────────────────
7\. NOTES SUPPLÉMENTAIRES SUR L’AGENT IA ET LA MANIPULATION DE LA MÉMOIRE
────────────────────────────────────────────────────────────
• Le module Agent IA orchestre les réponses intelligentes et les appels d’outils.
• Les fonctionnalités clés incluent :
– Le traitement de l’entrée utilisateur via le paramètre "text".
– L’orientation du comportement via un "options.systemMessage" détaillé (qui peut inclure la mémoire, les règles d’appel d’outils, et les réponses de repli).
– La connexion à des nœuds mémoire (ex. : memoryBufferWindow) pour la rétention de contexte.

**Bonnes pratiques :**
– Rédiger des messages système complets qui couvrent les cas limites.
– Utiliser des expressions dynamiques pour s’adapter à des entrées variées.
– Tester l’intégralité du flux conversationnel pour garantir que les valeurs dynamiques (ex. : détails d’événements) se transmettent correctement entre les nœuds.
– Valider les sorties JSON pour éviter les problèmes courants de valeurs de propriétés (voir Section 6).

────────────────────────────────────────────────────────────
8\. PROBLÈMES COURANTS DE VALEURS DE PROPRIÉTÉS AVEC LES JSON GÉNÉRÉS PAR LLM
────────────────────────────────────────────────────────────
• **Guillemets :**
– Utiliser des guillemets doubles pour les noms de propriété et les chaînes de caractères.
• **Virgules finales :**
– Éviter les virgules après le dernier élément dans les objets ou tableaux.
• **Incohérences de type de données :**
– Ne pas entourer de guillemets les valeurs numériques ou booléennes.
• **Sensibilité à la casse :**
– S’assurer que les noms de propriété respectent la casse attendue.
• **Crochets/Accolades :**
– Vérifier que toutes les structures JSON sont correctement ouvertes et fermées.
• **Validation :**
– Passer votre JSON par des validateurs pour détecter les erreurs de syntaxe.
• **Instructions au LLM :**
– Lors de la demande de génération de JSON à un LLM, spécifier “générer du JSON valide” et avertir de ces pièges courants.

────────────────────────────────────────────────────────────
9\. CONCLUSIONS FINALES
────────────────────────────────────────────────────────────
• **Nœuds de déclenchement de chat :**
– Servent de points d’entrée pour les workflows basés sur la conversation avec des paramètres nuancés pour l’accès public et les messages d’accueil dynamiques.
• **Nœuds Post-it :**
– Fournissent une documentation interne aux workflows et sont essentiels à la clarté dans des structures complexes.
• **Module Agent IA :**
– Intègre l’entrée utilisateur, la mémoire dynamique, et les appels d’outils pour générer des réponses contextuelles.
• **Outils d’intégration :**
– Chaque outil externe (Pinecone, Airtable, PostgreSQL, Google Docs/Calendar, Telegram, Requête HTTP, SerpAPI, outil de workflow, Gmail, Supabase) possède des besoins de configuration spécifiques et nécessite un mappage de champs précis.
• **JSON généré par LLM :**
– Traiter les problèmes courants de valeurs de propriétés par un formatage et une validation rigoureux.
• **En résumé :**
– Combiner des structures de nœuds bien documentées avec des configurations d’intégration rigoureuses permet de créer des workflows robustes et maintenables.

\================================================================
FIN DE LA FICHE MÉMO COMPLÈTE
=============================
