# n8n Workflow Creation Documentation

## Key Node Examples
 #1 ================
{
  "id": "20a2d959-5412-447b-a2c4-7736b6b758b3",
  "name": "When chat message received",
  "type": "@n8n/n8n-nodes-langchain.chatTrigger",
  "position": [
    -320,
    1600
  ],
  "webhookId": "8ba8fa53-2c24-47a8-b4dd-67b88c106e3d",
  "parameters": {
    "options": {}
  },
  "typeVersion": 1.1
}


================ Node #6 ================
{
  "id": "50271e59-6dd2-4f54-9b28-dd4a9f33ddc5",
  "name": "Chat Response",
  "type": "n8n-nodes-base.set",
  "position": [
    1440,
    1600
  ],
  "parameters": {
    "options": {},
    "assignments": {
      "assignments": [
        {
          "id": "d6f68b1c-a6a6-44d4-8686-dc4dcdde4767",
          "name": "output",
          "type": "string",
          "value": "={{ $json.output }}"
        }
      ]
    }
  },
  "typeVersion": 3.4
}


================ Node #11 ================
{
  "id": "15bb5fd5-7dfe-4da9-830c-e1d905831640",
  "name": "Telegram Response",
  "type": "n8n-nodes-base.telegram",
  "position": [
    1440,
    1260
  ],
  "parameters": {
    "text": "={{ $json.output }}",
    "chatId": "=1234567891",
    "additionalFields": {
      "parse_mode": "HTML",
      "appendAttribution": false
    }
  },
  "credentials": {
    "telegramApi": {
      "id": "pAIFhguJlkO3c7aQ",
      "name": "Telegram account"
    }
  },
  "typeVersion": 1.2
}


================ Node #12 ================
{
  "id": "8cc38a87-e214-4193-9fe6-ba4adc3d5530",
  "name": "Sticky Note1",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    1360,
    1160
  ],
  "parameters": {
    "width": 260,
    "height": 300,
    "content": "## Telegram \n(Optional)"
  },
  "typeVersion": 1
}


================ Node #13 ================
{
  "id": "38121a81-d768-4bb0-a9e6-39de0906e026",
  "name": "Sticky Note2",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    680,
    1500
  ],
  "parameters": {
    "color": 5,
    "width": 1320,
    "height": 780,
    "content": "## AI AGENT with Long Term Memory & Note Storage"
  },
  "typeVersion": 1
}


================ Node #15 ================
{
  "id": "68303b67-2203-41e8-b370-220d884d2945",
  "name": "AI Tools Agent",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [
    1060,
    1600
  ],
  "parameters": {
    "text": "={{ $('When chat message received').item.json.chatInput }}",
    "options": {
      "systemMessage": ""
    },
    "promptType": "define"
  },
  "typeVersion": 1.7,
  "alwaysOutputData": false
}


================ Node #21 ================
{
  "id": "48d576fc-870a-441e-a7be-3056ef7e1d7a",
  "name": "Merge",
  "type": "n8n-nodes-base.merge",
  "position": [
    340,
    1600
  ],
  "parameters": {},
  "typeVersion": 3
}


================ Node #22 ================
{
  "id": "b7b70ba1-0267-4d2b-91f4-5cc4fd22fd03",
  "name": "Chat Message Trigger",
  "type": "@n8n/n8n-nodes-langchain.chatTrigger",
  "position": [
    -1940,
    160
  ],
  "webhookId": "cb0b9dbe-1f35-441a-b062-29624b0ebc6a",
  "parameters": {
    "options": {}
  },
  "typeVersion": 1.1
}


================ Node #25 ================
{
  "id": "4ab360eb-858f-48b8-a00d-71867d4f0c93",
  "name": "Parse and Chunk JSON Data",
  "type": "n8n-nodes-base.code",
  "position": [
    -1420,
    160
  ],
  "parameters": {
    "jsCode": "// Parse the input JSON string and split it into four chunks\nconst rawText = $json.text;\n\n// Remove Markdown JSON code blocks if present\nconst cleanedText = rawText.replace(/```json|```/g, '').trim();\n\ntry {\n const jsonArray = JSON.parse(cleanedText);\n if (!Array.isArray(jsonArray)) {\n throw new Error('The JSON is not an array.');\n }\n const chunkSize = Math.ceil(jsonArray.length / 4);\n const chunks = [];\n for (let i = 0; i < jsonArray.length; i += chunkSize) {\n chunks.push(jsonArray.slice(i, i + chunkSize));\n }\n return chunks.map(chunk => ({ json: { chunk } }));\n} catch (error) {\n return [{ json: { error: error.message } }];\n}\n"
  },
  "typeVersion": 2
}


================ Node #28 ================
{
  "id": "e21bbdf6-a903-491e-920c-ef7576f9ce80",
  "name": "Format SerpAPI Organic Results",
  "type": "n8n-nodes-base.code",
  "position": [
    -460,
    140
  ],
  "parameters": {
    "jsCode": "// Format the organic search results from SerpAPI\nconst results = $input.first().json.organic_results;\nif (results.length === 0) {\n return [{ json: { error: 'No search results found.' } }];\n}\nconst formattedResults = results.map(result => ({\n title: result.title || 'No title available',\n url: result.link || 'No link available',\n source: result.source || result.displayed_link || 'Unknown source'\n}));\nreturn formattedResults.map(result => ({ json: result }));\n"
  },
  "typeVersion": 2
}


================ Node #29 ================
{
  "id": "a856c8e8-5c3c-4a2f-9086-66deee1afd06",
  "name": "Extract Relevant Context via LLM",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [
    -1280,
    520
  ],
  "parameters": {
    "text": "=User Queries: {{ $('Parse and Chunk JSON Data').all().map(item => item.json.chunk[0]).join(', ') }}\nWebpage Contents: \n\"\"\"\n{{ $json.data }}\n\"\"\"",
    "options": {
      "systemMessage": "=You are an expert information extractor. Given the user's query, the search query that led to this page, and the webpage content, extract all relevant pieces of information that are useful to answer the query. Return only the relevant context as plain text without any additional commentary."
    },
    "promptType": "define"
  },
  "typeVersion": 1.7
}


================ Node #30 ================
{
  "id": "6d5c6698-0b4f-438c-91b9-3597f5d3e904",
  "name": "Generate Comprehensive Research Report",
  "type": "@n8n/n8n-nodes-langchain.agent",
  "position": [
    -740,
    520
  ],
  "parameters": {
    "text": "=Extracted Contexts (Merged):\n\"\"\"\n{{ $json.output }}\n\"\"\"",
    "options": {
      "systemMessage": "You are an expert researcher and report writer. Based on the gathered contexts and the original user query, generate a comprehensive, well-structured report. Include all relevant insights and conclusions without unnecessary commentary.\n\nFormat the report in Markdown with clear headings. For example:\n\n# Research Report: [User Query]\n\n## Key Findings\n- Point 1\n- Point 2\n\n## Detailed Analysis\n### Aspect 1\nSummary of findings.\n_Source:_ [Source Name](URL)\n\n### Aspect 2\nSummary of findings.\n_Source:_ [Another Source](URL)\n\nNow, generate the complete report."
    },
    "promptType": "define"
  },
  "typeVersion": 1.7
}


================ Node #36 ================
{
  "id": "b25c148e-047d-40a7-8818-94c3504828dd",
  "name": "Sticky Note: SerpAPI Setup",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    -940,
    -20
  ],
  "parameters": {
    "color": 7,
    "width": 420,
    "height": 140,
    "content": "## SerpAPI Setup Instructions\n1. Obtain your API key from https://serpapi.com/manage-api-key.\n2. Save your API key securely in n8n credentials (do not use plain text)."
  },
  "typeVersion": 1
}


================ Node #37 ================
{
  "id": "e69c9a85-31e4-42b9-a09a-683ec5bb97d1",
  "name": "Sticky Note: Jina AI Setup",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    -60,
    -40
  ],
  "parameters": {
    "color": 7,
    "width": 420,
    "height": 140,
    "content": "## Jina AI Setup Instructions\n1. Obtain your API key from https://jina.ai/api-dashboard/key-manager.\n2. Configure your Jina AI credential in n8n to ensure secure API access."
  },
  "typeVersion": 1
}


================ Node #38 ================
{
  "id": "dbd204e0-da8e-41d8-814b-f409a23e9573",
  "name": "Sticky Note: OpenRouter API Setup",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    -1680,
    460
  ],
  "parameters": {
    "color": 7,
    "width": 300,
    "height": 180,
    "content": "## OpenRouter API Setup Instructions\n1. Obtain your API key from https://openrouter.ai/settings/keys.\n2. Set up your OpenRouter credential in n8n for secure integration."
  },
  "typeVersion": 1
}


================ Node #39 ================
{
  "id": "23b50c07-39a8-4166-ab13-9683b3ee25e6",
  "name": "Check User & Chat ID",
  "type": "n8n-nodes-base.if",
  "position": [
    -80,
    160
  ],
  "parameters": {
    "options": {},
    "conditions": {
      "options": {
        "version": 2,
        "leftValue": "",
        "caseSensitive": true,
        "typeValidation": "strict"
      },
      "combinator": "and",
      "conditions": [
        {
          "id": "5fe3c0d8-bd61-4943-b152-9e6315134520",
          "operator": {
            "name": "filter.operator.equals",
            "type": "string",
            "operation": "equals"
          },
          "leftValue": "={{ $('Listen for Telegram Events').item.json.body.message.from.first_name }}",
          "rightValue": "={{ $json.first_name }}"
        },
        {
          "id": "98a0ea91-0567-459c-bbce-06abc14a49ce",
          "operator": {
            "name": "filter.operator.equals",
            "type": "string",
            "operation": "equals"
          },
          "leftValue": "={{ $('Listen for Telegram Events').item.json.body.message.from.last_name }}",
          "rightValue": "={{ $json.last_name }}"
        },
        {
          "id": "18a96c1f-f2a0-4a2a-b789-606763df4423",
          "operator": {
            "type": "number",
            "operation": "equals"
          },
          "leftValue": "={{ $('Listen for Telegram Events').item.json.body.message.from.id }}",
          "rightValue": "={{ $json.id }}"
        }
      ]
    },
    "looseTypeValidation": "="
  },
  "typeVersion": 2.2
}


================ Node #40 ================
{
  "id": "ecbc13fe-305d-4cdd-b35c-3e119e8e8b5d",
  "name": "Error message",
  "type": "n8n-nodes-base.telegram",
  "position": [
    160,
    440
  ],
  "parameters": {
    "text": "=Unable to process your message.",
    "chatId": "={{ $json.body.message.chat.id }}",
    "additionalFields": {
      "appendAttribution": false
    }
  },
  "credentials": {
    "telegramApi": {
      "id": "pAIFhguJlkO3c7aQ",
      "name": "Telegram account"
    }
  },
  "typeVersion": 1.2
}


================ Node #41 ================
{
  "id": "be722bc7-0b22-4892-967c-fdd398a7b129",
  "name": "Sticky Note",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    -540,
    -20
  ],
  "parameters": {
    "color": 6,
    "width": 949,
    "height": 652,
    "content": "# Receive Telegram Message with Webhook"
  },
  "typeVersion": 1
}


================ Node #42 ================
{
  "id": "a3866585-bfee-4025-a8f4-f06fde16171a",
  "name": "Listen for Telegram Events",
  "type": "n8n-nodes-base.webhook",
  "position": [
    -480,
    160
  ],
  "webhookId": "097f36f3-1574-44f9-815f-58387e3b20bf",
  "parameters": {
    "path": "wbot",
    "options": {
      "binaryPropertyName": "data"
    },
    "httpMethod": "POST"
  },
  "typeVersion": 2
}


================ Node #43 ================
{
  "id": "f70571d5-3680-4616-90fa-3358b0883368",
  "name": "Sticky Note1",
  "type": "n8n-nodes-base.stickyNote",
  "position": [
    -1380,
    -20
  ],
  "parameters": {
    "color": 7,
    "width": 800,
    "height": 860,
    "content": "# How to set up a Telegram Bot WebHook\n\n## WebHook Setup Process\n\n**Basic Concept**\nA WebHook allows your Telegram bot to automatically receive updates instead of manually polling the Bot API.\n\n**Setup Method**\nTo set a WebHook, make a GET request using this URL format:\n```\nhttps://api.telegram.org/bot{my_bot_token}/setWebhook?url={url_to_send_updates_to}\n```\nWhere:\n- `my_bot_token`: Your bot token from BotFather\n- `url_to_send_updates_to`: Your HTTPS endpoint that handles bot updates\n\n\n**Verification**\nTo verify the WebHook setup, use:\n```\nhttps://api.telegram.org/bot{my_bot_token}/getWebhookInfo\n```\n\nA successful response looks like:\n```json\n{\n \"ok\": true,\n \"result\": {\n \"url\": \"https://www.example.com/my-telegram-bot/\",\n \"has_custom_certificate\": false,\n \"pending_update_count\": 0,\n \"max_connections\": 40\n }\n}\n```\n\n\nThis method provides a simple and efficient way to handle Telegram bot updates automatically through webhooks rather than manual polling."
  },
  "typeVersion": 1
}




## Essential Reference Guide
Fiche Mémo des Nœuds d’Automatisation n8n

Cette fiche mémo fournit des extraits de configuration JSON pour les nœuds n8n courants, classés par fonction. Chaque extrait montre comment utiliser le nœud de manière programmatique (tel qu’il apparaîtrait dans le JSON d’un workflow). Utilisez ces exemples comme modèles pour créer des workflows. (Remarque : remplacez les valeurs fictives comme YOUR\_API\_KEY ou YOUR\_ID par des valeurs réelles. Les identifiants sont référencés par nom/ID après leur configuration dans n8n.)

Intégrations IA & LLM

Modèle de conversation OpenAI (GPT-3.5/GPT-4) : Utilise l’API Chat d’OpenAI pour générer des réponses. Vous spécifiez le modèle, les invites, et des paramètres comme la température. Ce nœud peut prendre une invite système et une invite utilisateur pour générer une réponse. Par exemple, pour utiliser le modèle GPT-3.5 Turbo avec un rôle système et un message utilisateur :

```json
{
  "name": "ChatGPT",
  "type": "n8n-nodes-langchain.lmChatOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "gpt-3.5-turbo",
    "temperature": 0.7,
    "maxTokens": 500,
    "systemPrompt": "You are a helpful assistant.",
    "userPrompt": "Hello! How can I automate tasks with n8n?"
  },
  "credentials": {
    "openAiApi": {
      "id": "YOUR_CRED_ID",
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cette configuration définit le nœud Chat OpenAI pour utiliser le modèle GPT-3.5 avec un message système fournissant le contexte et un message utilisateur. La réponse sera disponible en sortie du nœud. Assurez-vous d’avoir configuré un identifiant API OpenAI nommé « OpenAI API », référencé dans les identifiants. Vous pouvez ajuster la température pour la créativité et maxTokens pour la longueur de la réponse.

Complétion de texte OpenAI : Pour les modèles de complétion GPT-3 (comme text-davinci-003), vous pouvez utiliser le nœud OpenAI en mode complétion. Fournissez une invite et des paramètres. Par exemple :

```json
{
  "name": "OpenAI Completion",
  "type": "n8n-nodes-langchain.openai",
  "typeVersion": 1,
  "parameters": {
    "model": "text-davinci-003",
    "prompt": "Summarize the following text: {{$json[\"content\"]}}",
    "temperature": 0.5,
    "maxTokens": 200
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela envoie une invite à l’endpoint de complétion d’OpenAI pour résumer un contenu provenant des données d’entrée. La syntaxe `{{$json["content"]}}` insère les données du nœud précédent. Le nœud utilise les identifiants API OpenAI. Le résultat apparaît dans le JSON de sortie du nœud (champ result contenant le texte généré).

Agents IA (avec outils) : n8n prend en charge des nœuds d’Agent avancés qui permettent à un modèle IA d’utiliser des outils (comme la recherche web, les calculatrices ou d’autres fonctions de nœuds) pour accomplir des tâches. Par exemple, l’Agent avec fonctions OpenAI peut appeler des fonctions personnalisées, et l’Agent ReAct utilise la stratégie ReAct pour décider quel outil utiliser à chaque étape. Voici un exemple simplifié de configuration de nœud Agent IA utilisant un modèle OpenAI et un outil (par ex., un outil de recherche Google) :

```json
{
  "name": "Agent IA (ReAct)",
  "type": "n8n-nodes-langchain.agent",
  "typeVersion": 1,
  "parameters": {
    "agentType": "react",
    "model": "gpt-4",
    "memory": false,
    "tools": [
      {
        "name": "googleSearch",
        "input": "What is n8n?"
      }
    ]
  }
}
```

Explication : Cet agent est configuré pour utiliser la stratégie ReAct avec GPT-4. Le tableau des outils correspond à de véritables nœuds Tool connectés au nœud Agent (par exemple, un nœud de recherche Google dans le workflow). En pratique, vous ajoutez les outils via l’interface graphique (ils deviennent des sous-nœuds). L’agent décide quand utiliser l’outil. Par exemple, il pourrait utiliser l’outil Google Search pour récupérer des informations nécessaires à une réponse. Remarque : Le cluster de nœuds Agent gère la logique ; assurez-vous d’avoir configuré les bons outils et identifiants (comme les clés API Google). Les agents peuvent aussi utiliser d'autres modes comme OpenAI Functions Agent, Plan-and-Execute Agent ou SQL Agent, chacun permettant à l’IA d’exécuter des tâches complexes spécifiques (par ex. appeler des fonctions définies, découper une tâche en sous-tâches, ou exécuter des requêtes SQL via des identifiants DB).

**Vecteurs et Bases de Données Vectorielles :** n8n propose des nœuds pour générer des embeddings de texte avec des modèles (OpenAI, Cohere, Google PaLM, etc.) et pour les stocker/interroger dans des bases vectorielles (Pinecone, Weaviate, etc.). Par exemple, le nœud OpenAI Embeddings peut prendre un texte et retourner un vecteur. L’utilisation est simple : vous spécifiez le champ texte à transformer et le modèle. La sortie est généralement un tableau de nombres représentant le vecteur. Ceux-ci peuvent être utilisés avec un nœud de type Vector Store (comme Pinecone) pour insérer ou interroger des vecteurs. Exemple d’un nœud OpenAI Embedding :

```json
{
  "name": "Text to Vector",
  "type": "n8n-nodes-langchain.embeddingsOpenAi",
  "typeVersion": 1,
  "parameters": {
    "model": "text-embedding-ada-002",
    "text": "={{ $json[\"content\"] }}"
  },
  "credentials": {
    "openAiApi": {
      "name": "OpenAI API"
    }
  }
}
```

Explication : Cela prend le champ "content" du JSON d’entrée et génère un embedding à 1536 dimensions à l’aide du modèle ada d’OpenAI. Ce vecteur est généralement envoyé vers un stockage ou utilisé dans une recherche par similarité. Pour le stockage, un nœud Pinecone (ou autre DB vectorielle) peut être utilisé avec des opérations comme Insérer un vecteur ou Interroger un vecteur (vous fournissez le nom de l’index, les données du vecteur, et d’éventuels métadonnées ou vecteurs de requête). L’usage des bases vectorielles pouvant être complexe, consultez la documentation du nœud pour les paramètres exacts. Le concept clé est que les nœuds Embeddings convertissent du texte en vecteurs numériques, et les nœuds Vector Store permettent de stocker et interroger ces vecteurs, ce qui permet des workflows comme la recherche sémantique ou la génération augmentée par récupération.

**Intégrations API & Webhooks**

**Nœud HTTP Request (APIs REST)** : C’est le nœud universel pour appeler toute API RESTful. Vous pouvez configurer la méthode, l’URL, les en-têtes, les paramètres de requête et le corps (y compris un corps JSON). Il prend en charge l’authentification via des identifiants (OAuth2, jeton API, etc.) ou des en-têtes personnalisés. Voici un exemple de requête GET avec paramètres :

```json
{
  "name": "HTTP GET Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/data",
    "method": "GET",
    "responseFormat": "json",
    "queryParametersUi": {
      "parameter": [
        { "name": "q", "value": "search term" },
        { "name": "limit", "value": "10" }
      ]
    }
  }
}
```

Pour effectuer un POST avec un corps JSON, utilisez `jsonParameters: true` et fournissez l’objet `bodyParametersJson` (ou les données de formulaire, etc.). Exemple de requête POST :

```json
{
  "name": "HTTP POST Example",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 1,
  "parameters": {
    "url": "https://api.example.com/posts",
    "method": "POST",
    "responseFormat": "json",
    "jsonParameters": true,
    "options": {
      "bodyContentType": "json"
    },
    "bodyParametersJson": {
      "title": "Hello World",
      "content": "This is an example post via n8n."
    }
  },
  "credentials": {
    "httpBasicAuth": {
      "name": "Example API Auth"
    }
  }
}
```

Explication : Ce POST enverra une charge utile JSON avec `title` et `content`. On définit `bodyContentType` sur JSON pour s'assurer de l’en-tête `Content-Type: application/json`. La section des identifiants (optionnelle) peut référencer une authentification HTTP Basic, OAuth2, ou un identifiant API selon les besoins de l’API. Le nœud HTTP est très flexible – vous pouvez aussi l’utiliser pour GraphQL en envoyant une requête GraphQL dans le corps ou en utilisant le nœud dédié GraphQL.

```json
{
  "name": "GraphQL Query",
  "type": "n8n-nodes-base.graphql",
  "typeVersion": 1,
  "parameters": {
    "endpoint": "https://api.spacex.land/graphql/",
    "query": "query Launches($limit:Int!) {\n launchesPast(limit: $limit) {\n mission_name\n launch_date_utc\n }\n}",
    "variables": "{ \"limit\": 3 }",
    "headerParametersUi": {
      "parameter": [
        { "name": "Authorization", "value": "Bearer YOUR_API_TOKEN" }
      ]
    }
  }
}
```

Explication : Cela interroge l’API GraphQL de SpaceX pour les 3 derniers lancements. Un token Bearer est inclus dans les en-têtes (si l’API nécessite une authentification). Le résultat sera un JSON dans la sortie du nœud. Le nœud GraphQL envoie automatiquement la requête au format JSON à l’endpoint. Vous pouvez également intégrer des données dynamiques avec des expressions n8n dans la requête ou les variables.

---

```json
{
  "name": "Webhook Trigger",
  "type": "n8n-nodes-base.webhook",
  "typeVersion": 1,
  "parameters": {
    "path": "incoming-data",
    "methods": ["POST"],
    "responseMode": "onReceived",
    "responseData": {
      "statusCode": 200,
      "body": "Webhook received successfully"
    }
  }
}
```

Explication : Cela crée un webhook à l’URL `/webhook/incoming-data` (l’URL complète est visible dans l’interface n8n). Il écoute les requêtes POST. `responseMode: onReceived` signifie que n8n enverra immédiatement une réponse dès que la requête est reçue (sans attendre la fin du workflow), avec une réponse statique 200 OK. Pour accéder aux données de la requête, utilisez `{{$json["body"]["fieldName"]}}` dans les nœuds suivants. Idéal pour des services comme Stripe, GitHub ou des intégrations personnalisées.

---

```json
{
  "name": "Webhook Response",
  "type": "n8n-nodes-base.respondToWebhook",
  "typeVersion": 1,
  "parameters": {
    "responseMode": "responseNode",
    "options": {
      "responseData": {
        "body": "{ \"success\": true, \"message\": \"Processed\" }",
        "headers": {
          "Content-Type": "application/json"
        },
        "statusCode": 200
      }
    }
  }
}
```

Explication : Placez ce nœud à l’endroit où vous souhaitez répondre au webhook. Une fois exécuté, n8n envoie la réponse spécifiée et ne poursuit pas l’exécution des nœuds suivants. Si vous souhaitez continuer le workflow après la réponse, utilisez l’option “respond and continue”. Utile pour les cas où une réponse immédiate est nécessaire, suivie de traitements en arrière-plan.

```json
{
  "name": "Add Field",
  "type": "n8n-nodes-base.function",
  "typeVersion": 1,
  "parameters": {
    "functionCode": "for (const item of items) {\n item.json.newField = item.json.someField + 100;\n}\nreturn items;"
  }
}
```

Explication : Ce nœud de code JavaScript parcourt chaque élément d'entrée et ajoute un nouveau champ `newField` en lui assignant la valeur de `someField + 100`. Le nœud retourne les items modifiés. Vous pouvez y effectuer des transformations plus complexes ou générer des données si aucun input n'est défini.

---

```json
{
  "name": "Check Status",
  "type": "n8n-nodes-base.if",
  "typeVersion": 2,
  "parameters": {
    "conditions": {
      "conditions": [
        {
          "leftValue": "={{ $json[\"status\"] }}",
          "rightValue": "success",
          "operator": {
            "type": "string",
            "operation": "equals"
          }
        }
      ],
      "combinator": "and"
    }
  }
}
```

Explication : Ce nœud IF vérifie si le champ `status` est égal à `"success"`. Si oui, l’élément est dirigé vers la sortie vraie, sinon vers la fausse. Vous pouvez ajouter d’autres règles et les combiner avec `and` ou `or`.

---

```json
{
  "name": "Route by Category",
  "type": "n8n-nodes-base.switch",
  "typeVersion": 1,
  "parameters": {
    "dataType": "string",
    "value1": "={{ $json[\"category\"] }}",
    "rules": {
      "rules": [
        { "operation": "equal", "value2": "support" },
        { "operation": "equal", "value2": "sales" }
      ]
    },
    "fallbackOutput": 2
  }
}
```

Explication : Ce nœud Switch examine la valeur du champ `category`. Si elle vaut `"support"`, l’élément va à la sortie 0 ; si `"sales"`, à la sortie 1 ; sinon, à la sortie 2. Pratique pour diriger les données selon plusieurs cas.

---

```json
{
  "name": "Set Fields",
  "type": "n8n-nodes-base.set",
  "typeVersion": 3,
  "parameters": {
    "keepOnlySet": false,
    "values": {
      "number": [
        {
          "name": "year",
          "value": 2025
        }
      ],
      "string": [
        {
          "name": "statusMessage",
          "value": "Processed by n8n"
        }
      ]
    }
  }
}
```

Explication : Ce nœud ajoute deux champs : un nombre `year` et une chaîne `statusMessage`. Comme `keepOnlySet` est à false, les autres champs existants sont conservés. C’est utile pour enrichir ou transformer les données avant de les envoyer ailleurs.

```json
{
  "name": "Merge on ID",
  "type": "n8n-nodes-base.merge",
  "typeVersion": 1,
  "parameters": {
    "mode": "mergeByKey",
    "propertyName": "id",
    "outputDataFrom": "both"
  }
}
```

Explication : Ce nœud Merge combine deux flux de données en fonction du champ `id`. Il associe les éléments d'entrée 1 et 2 qui ont la même valeur d'identifiant. Le champ `outputDataFrom: "both"` signifie que les données fusionnées incluront les champs des deux entrées. Utilisez-le pour regrouper des données séparées après traitement parallèle.

---

```json
{
  "name": "Split Array",
  "type": "n8n-nodes-base.itemLists",
  "typeVersion": 1,
  "parameters": {
    "operation": "splitIntoItems",
    "property": "results"
  }
}
```

Explication : Ce nœud transforme un champ `results` contenant un tableau en plusieurs éléments distincts, chacun contenant un seul élément du tableau. Idéal pour gérer les réponses d’API ou des champs de données groupés.

---

```json
{
  "name": "Batch Loop",
  "type": "n8n-nodes-base.splitInBatches",
  "typeVersion": 1,
  "parameters": {
    "batchSize": 10
  }
}
```

Explication : Ce nœud permet de traiter les éléments en lots de 10. Il envoie les premiers 10 éléments, attend un retour via son entrée secondaire pour envoyer le lot suivant. Cela permet un traitement itératif (comme une boucle), utile pour limiter les appels API ou éviter une surcharge. Le processus se répète jusqu'à épuisement des éléments.

```json
{
  "name": "Stop on Condition",
  "type": "n8n-nodes-base.stopAndError",
  "typeVersion": 1,
  "parameters": {
    "message": "Terminating workflow due to business rule X"
  }
}
```

Explication : Ce nœud arrête volontairement le workflow avec un message d'erreur personnalisé. Il est utile après une condition (IF) pour bloquer l'exécution si un critère métier n'est pas respecté. L’exécution s’interrompt et une erreur est générée.

---

```json
{
  "name": "Daily Schedule",
  "type": "n8n-nodes-base.cron",
  "typeVersion": 1,
  "parameters": {
    "triggerTimes": {
      "item": [
        { "hour": 9, "minute": 0 },
        { "hour": 17, "minute": 0 }
      ]
    }
  }
}
```

Explication : Ce nœud déclenche le workflow chaque jour à 9h00 et 17h00. Il s'agit d'un déclencheur planifié via le nœud Cron. Aucun input n’est requis, et un élément vide est envoyé pour initier le workflow.

---

```json
{
  "name": "Email Trigger",
  "type": "n8n-nodes-base.emailReadImap",
  "typeVersion": 1,
  "parameters": {
    "mailbox": "INBOX",
    "postProcessAction": "read",
    "options": {
      "criteria": "UNSEEN"
    }
  },
  "credentials": {
    "imap": {
      "name": "My Email Account"
    }
  }
}
```

Explication : Ce nœud surveille la boîte de réception IMAP et déclenche le workflow à la réception d’un email non lu, qu’il marque ensuite comme lu. Il permet d’automatiser des réponses ou extractions depuis des emails entrants.

---

```json
{
  "name": "Manual Trigger",
  "type": "n8n-nodes-base.manualTrigger",
  "typeVersion": 1,
  "parameters": {}
}
```

Explication : Ce nœud démarre le workflow manuellement depuis l’interface n8n (bouton "Exécuter le workflow"). Il ne contient aucun paramètre et génère un élément vide pour initier le traitement.

---

```json
{
  "name": "Run Sub-workflow",
  "type": "n8n-nodes-base.executeWorkflow",
  "typeVersion": 1,
  "parameters": {
    "workflowId": "123",
    "waitForCompletion": true,
    "inputs": {
      "inputData": "={{ $json[\"data\"] }}"
    }
  }
}
```

Explication : Ce nœud appelle un sous-workflow (ID `123`) depuis un workflow principal. Il attend que l'exécution soit terminée (`waitForCompletion: true`) et transmet une donnée d’entrée nommée `inputData`. Le sous-workflow doit inclure un nœud `Workflow Trigger` pour recevoir l’appel.

```json
{
  "name": "Send Slack Message",
  "type": "n8n-nodes-base.slack",
  "typeVersion": 1,
  "parameters": {
    "resource": "message",
    "operation": "send",
    "channel": "C01234567",
    "text": "Hello from n8n :tada:"
  },
  "credentials": {
    "slackApi": {
      "name": "Slack OAuth2"
    }
  }
}
```

Explication : Ce nœud envoie le message "Hello from n8n 🎉" dans le canal Slack spécifié. Le canal peut être un ID ou un nom (assurez-vous que les autorisations nécessaires sont définies dans l’application Slack). Ce nœud utilise un identifiant Slack OAuth2.

---

```json
{
  "name": "Append to Sheet",
  "type": "n8n-nodes-base.googleSheets",
  "typeVersion": 4,
  "parameters": {
    "operation": "append",
    "spreadsheetId": "1A2b3C4D5E6FgHiJkLMnoPQrstu",
    "sheetName": "Sheet1",
    "dataMode": "autoMap",
    "options": {
      "valueInputMode": "USER_ENTERED"
    }
  },
  "credentials": {
    "googleSheetsOAuth2Api": {
      "name": "Google Sheets OAuth2"
    }
  }
}
```

Explication : Ce nœud ajoute une ligne à une feuille Google Sheets nommée "Sheet1". Il utilise le mode `autoMap` pour faire correspondre automatiquement les champs d'entrée avec les colonnes. Le mode `USER_ENTERED` fait en sorte que les formules soient recalculées comme si un utilisateur avait saisi les données.

---

```json
{
  "name": "Query Notion DB",
  "type": "n8n-nodes-base.notion",
  "typeVersion": 2,
  "parameters": {
    "resource": "databasePage",
    "operation": "getAll",
    "databaseId": "YOUR_NOTION_DATABASE_ID",
    "options": {
      "filter": {
        "singleCondition": {
          "key": "Email|email",
          "condition": "equals",
          "emailValue": "={{ $json[\"email\"] }}"
        }
      }
    }
  },
  "credentials": {
    "notionApi": {
      "name": "Notion API"
    }
  }
}
```

Explication : Ce nœud interroge une base de données Notion et renvoie les pages dont le champ "Email" correspond à la valeur provenant des données entrantes. Il utilise l’opération `getAll` sur la ressource `databasePage` avec un filtre conditionnel. Un identifiant d’API Notion est requis.

```json
{
  "name": "Create GitHub Issue",
  "type": "n8n-nodes-base.github",
  "typeVersion": 1,
  "parameters": {
    "resource": "issue",
    "operation": "create",
    "owner": "octocat",
    "repository": "Hello-World",
    "title": "Automated Issue from n8n",
    "body": "This issue was created by an n8n workflow."
  },
  "credentials": {
    "githubApi": {
      "name": "GitHub personal access token"
    }
  }
}
```

Explication : Ce nœud crée un ticket GitHub dans le dépôt `octocat/Hello-World`. Il utilise un token personnel GitHub configuré dans les identifiants. Vous pouvez aussi utiliser d'autres opérations sur les issues, les commits, les pull requests, etc.

---

```json
{
  "name": "MySQL Query",
  "type": "n8n-nodes-base.mySql",
  "typeVersion": 2,
  "parameters": {
    "operation": "executeQuery",
    "query": "SELECT * FROM users WHERE id = {{ $json[\"user_id\"] }}",
    "additionalFields": {}
  },
  "credentials": {
    "mySql": {
      "name": "My MySQL DB"
    }
  }
}
```

Explication : Ce nœud exécute une requête SQL personnalisée dans une base MySQL en injectant dynamiquement un `user_id`. Chaque ligne du résultat devient un item JSON. Évitez les injections SQL en contrôlant les données insérées dans les expressions.

---

Résumé des autres intégrations :

* **Notion (create/update/query pages)** : Très utile pour automatiser des tableaux de bord, notes, suivis de tâches.
* **Slack (messagerie, alertes)** : Envoi de messages, notifications automatiques, support de blocks JSON.
* **Google Sheets** : Lecture et écriture de feuilles, synchronisation de données, export automatisé.
* **GitHub** : Création de tickets, gestion des pull requests, intégration DevOps.
* **MySQL/PostgreSQL** : Intégration directe avec vos bases de données métiers pour lecture/écriture.
* **Autres services populaires :**

  * **AWS S3** : Upload/download de fichiers.
  * **Google Drive** : Gestion de fichiers cloud.
  * **Twilio** : SMS, WhatsApp.
  * **Stripe** : Paiements, événements.
  * **Jira, Trello, Asana** : Gestion de tâches.
  * **HubSpot, Salesforce** : CRM automatisé.
  * **Email SMTP / SendGrid** : Envoi d’emails transactionnels.
  * **Webhook/HTTP** : Intégration d’API ou de services personnalisés.
  * **CSV/XML** : Lecture/écriture de formats structurés.

Tous ces nœuds suivent le schéma : `resource` → `operation` → `paramètres`. Créez-les dans l’éditeur n8n, puis exportez en JSON pour les réutiliser ou les automatiser.

**Conseils d'utilisation :**

* **Expressions :**
  Les expressions comme `={{ $json["..."] }}` servent à récupérer des données d’un nœud précédent. Elles doivent être entre doubles accolades dans une chaîne JSON. n8n les évalue à l’exécution. Vous pouvez aussi utiliser `$node["NomDuNœud"].json["champ"]` pour pointer vers un champ précis d’un autre nœud, ou `$items()` pour accéder à plusieurs éléments.

* **Identifiants (Credentials) :**
  La section `"credentials"` dans chaque nœud lie le nœud à un identifiant stocké. Elle peut être de la forme `{ "id": "some-id", "name": "Credential Name" }` ou juste `"name"`. Lors de la création de workflows via l’API, le nom suffit s’il est unique. Assurez-vous que l’identifiant est bien configuré dans n8n avant usage.

* **ID de nœud et position :**
  Des champs comme `id` et `position` peuvent apparaître dans des exports. Ils ne sont pas nécessaires pour un guide comme celui-ci, mais sont utilisés par l’interface graphique pour positionner les nœuds. On peut les omettre si on se concentre uniquement sur la configuration fonctionnelle.

---

**Connexion des nœuds :**

Dans le JSON d’un workflow complet, la section `"connections"` relie les sorties des nœuds aux entrées d’autres nœuds. Exemple pour une chaîne Cron → GraphQL → Function → Slack :

```json
"connections": {
  "Cron": {
    "main": [
      [
        {
          "node": "GraphQL",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "GraphQL": {
    "main": [
      [
        {
          "node": "Summarize",
          "type": "main",
          "index": 0
        }
      ]
    ]
  },
  "Summarize": {
    "main": [
      [
        {
          "node": "Slack",
          "type": "main",
          "index": 0
        }
      ]
    ]
  }
}
```

Cela indique que la sortie du nœud `"Cron"` est connectée à l’entrée du nœud `"GraphQL"`, et ainsi de suite. Si vous créez un workflow via l’API, vous devez construire manuellement cette structure.

---

**Tests et itération :**
Commencez par un workflow simple (`Manual Trigger → un seul nœud → sortie`) pour valider votre structure JSON, puis ajoutez progressivement des étapes. Vous pouvez importer un JSON dans n8n via **Workflow → Import from JSON** pour le visualiser et le tester.

---

**Conclusion :**
Cette fiche a couvert les principales catégories et les nœuds les plus populaires (IA, webhooks, intégrations, traitement de données). En combinant ces exemples, vous pouvez automatiser une grande variété de processus dans n8n. Bonne automatisation !


```json
[
  {
    "json": {
      "property1": "value1",
      "property2": "value2"
    },
    "binary": {}
  },
  {
    "json": {
      "property1": "anotherValue1",
      "property2": "anotherValue2"
    },
    "binary": {}
  }
]
```

Explication : Dans n8n, les données circulent entre les nœuds sous forme d’un tableau d’objets appelés **items**. Chaque item possède une clé `json` (données structurées) et une clé `binary` (fichiers, le cas échéant). Les nœuds traitent chaque item individuellement, ce qui permet un traitement parallèle.

---

### Accès aux données avec les expressions

* `{{ $json.property1 }}` – accède à un champ simple.
* `{{ $json.parent.child.property }}` – accède à une propriété imbriquée.
* `{{ $node["NomDuNœud"].json.property }}` – accède aux données d’un autre nœud spécifique.

---

### Exemple – nœud Set en mode de mappage manuel :

```json
{
  "newField": "{{ $json.existingField }}",
  "combinedField": "{{ $json.firstName }} {{ $json.lastName }}",
  "staticField": "This is a static value"
}
```

Explication : Ce nœud crée trois champs :

* `newField` reprend la valeur d’un champ existant.
* `combinedField` combine deux champs.
* `staticField` insère une valeur fixe.

---

### Exemple – mode JSON Output du nœud Set :

```json
{
  "mode": "jsonOutput",
  "jsonOutput": {
    "newField": "{{ $json.existingField }}",
    "processedData": {
      "id": "{{ $json.id }}",
      "timestamp": "{{ $now }}"
    }
  }
}
```

Explication : Cette configuration produit une structure JSON personnalisée contenant un champ `newField` et un objet imbriqué `processedData` avec un ID et un horodatage dynamique.

---

### Prise en charge de la notation par point (dot notation)

```json
{
  "number": {
    "one": 20
  }
}
```

* Si vous utilisez `"name": "number.one"` avec une valeur `20`, le champ sera interprété comme `number.one` → `number: { one: 20 }`.
* Pour désactiver cela, ajoutez l’option `"supportDotNotation": false`.

---

### Nœud Code – transformations programmatiques

Le nœud **Code** (anciennement Function) permet de manipuler les données avec du **JavaScript** (ou Python, si activé). Il peut générer des données ou transformer les items entrants. Deux modes principaux :

* **Item-wise (par élément)** – boucle automatique sur chaque item
* **Manual/Batch** – contrôle complet sur `items[]` et retour groupé

Exemple simple en JavaScript :

```javascript
for (const item of items) {
  item.json.processed = true;
  item.json.fullName = `${item.json.firstName} ${item.json.lastName}`;
}
return items;
```

Explication : Ce code ajoute un champ `processed` à `true` et génère un champ `fullName` à partir des données existantes.

---

Cette section complète la fiche ultime n8n avec une compréhension approfondie du format de données, des expressions, du nœud Set, et de l’utilisation avancée du nœud Code.

```javascript
// Run Once for All Items
const newItems = [];

const inputData = $input.all().json;

for (const item of inputData) {
  newItems.push({
    json: {
      modifiedData: item.originalData,
      timestamp: new Date().toISOString()
    }
  });
}

return newItems;
```

Explication : Ce script traite tous les items en une seule fois. Il accède à tous les objets d'entrée avec `$input.all().json`, les transforme, et retourne un nouveau tableau.

---

```javascript
// Run Once for Each Item
const item = $json;

item.processed = true;
item.modifiedAt = new Date().toISOString();

return { json: item };
```

Explication : Ce script modifie chaque item indépendamment, ajoutant deux champs : `processed` et `modifiedAt`. Il retourne l’item enrichi.

---

```javascript
// Splitting JSON into Separate Items
let results = [];

for (const item of $('Webhook').all()) {
  const students = item.json.body.students;
  for (studentKey of Object.keys(students)) {
    results.push({
      json: students[studentKey]
    });
  }
}

return results;
```

Explication : Ce code prend une réponse JSON avec des données imbriquées (ici des étudiants) et les convertit en items individuels. Utile pour traiter chaque élément séparément dans les workflows.

---

### Syntaxe d'expressions de base

* `{{ $json.city }}` : Accède à la propriété `city` d’un JSON entrant, typiquement d’un webhook.
* `{{ $node["NodeName"].json.property }}` : Récupère une valeur d’un nœud spécifique précédent.

---

### Exemple de configuration d’un AI Agent (LangChain)

**Agent avec outils :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

**Agent conversationnel :**

```json
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

**Agent avec mémoire persistante :**

```json
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Export et import de workflows

Les workflows n8n sont sauvegardés au format JSON. Cela permet :

* de les importer/exporter facilement,
* de les versionner,
* de les partager ou les déployer automatiquement via API ou CLI.

Pour importer : **Menu Workflow → Import from JSON**.
Pour exporter : **Menu Workflow → Export → Copy JSON**.

C’est idéal pour collaborer, sauvegarder ou migrer vos automatisations.

```json
// XML to JSON Converter
{
  "operation": "convert",
  "source": "xml",
  "target": "json",
  "data": "{{ $json.xmlData }}"
}
```

```json
// CSV to JSON Converter
{
  "operation": "convert",
  "source": "csv",
  "target": "json",
  "data": "{{ $json.csvData }}"
}
```

```json
// Google Sheets Integration - Append or Update
{
  "operation": "appendOrUpdate",
  "sheetId": "YOUR_SHEET_ID",
  "range": "A:Z",
  "data": "{{ $json.rowData }}"
}
```

```json
// OpenAI Node to Generate Structured JSON
{
  "model": "gpt-4",
  "prompt": "Generate a JSON object with the following structure: {{ $json.structure }}",
  "temperature": 0.2,
  "output": "json"
}
```

---

### Copier/Coller un Workflow

* Utilisez **Ctrl+C / Cmd+C** dans l’éditeur pour copier un ou plusieurs nœuds.
* Utilisez **Ctrl+V / Cmd+V** dans un autre workflow pour les coller.
* n8n gère automatiquement les connexions et identifiants si compatibles.

---

### Importer un Workflow JSON

1. Créez un nouveau workflow.
2. Copiez le script JSON depuis une source externe.
3. Collez-le directement dans l’éditeur avec **Ctrl+V / Cmd+V**.
4. Reconnectez les identifiants requis.
5. Adaptez si besoin (prompts, IDs, etc.).
6. Sauvegardez.

---

### Boucler sur des données JSON

* Utilisez l’expression `{{ $json.body.block }}` dans un nœud **Item Lists** pour découper un tableau en items individuels.
* Chaque élément devient un item traitable indépendamment dans les nœuds suivants.

---

### Extraire des champs spécifiques d’un webhook

```text
{{ $json.body.ticker }}
{{ $json.body.tf }}
```

---

### Convertir une chaîne JSON en objet JSON

```javascript
// In a Code node
const parsedBody = JSON.parse($json.body);
return { json: parsedBody };
```

---

### Ajouter une donnée globale à tous les items (contexte partagé)

```javascript
// In a Code node
const results = [];
const eventName = $('Webhook').first().json.body.event.event_name;

for (const student of $json.body.students) {
  results.push({
    json: {
      ...student,
      eventName: eventName
    }
  });
}

return results;
```

Explication : Ceci combine des données contextuelles (`eventName`) extraites d’un autre nœud avec une liste d’éléments (étudiants), en les enrichissant individuellement. Utile après un découpage de tableau ou dans des boucles.

---

Avec ces derniers ajouts, votre **Ultimate N8n Automation Cheat Sheet** couvre désormais toutes les bases : import/export, boucles, conversions, intégration IA, enrichissement conditionnel, et services tiers.

```json
// Tools Agent (Default)
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are a helpful assistant that uses tools to find information and accomplish tasks.",
  "memory": true,
  "verbose": true
}
```

---

```json
// Conversational Agent
{
  "agent": "conversational",
  "model": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "temperature": 0.8
  },
  "systemMessage": "You are a helpful customer service agent for our company.",
  "memory": true
}
```

---

```json
// Memory-Enabled Agent
{
  "agent": "tools",
  "model": {
    "provider": "openai",
    "model": "gpt-4",
    "temperature": 0.7
  },
  "systemMessage": "You are an assistant with memory capabilities. Use your tools to remember important information from our conversations.",
  "memory": true,
  "tools": ["memory-add", "memory-retrieve"]
}
```

---

### Parsing AI Agent Output (String → JSON)

```javascript
// In a Code node
const outputStr = $json.output;

let parsedData;
try {
  parsedData = JSON.parse(outputStr);
  return { json: parsedData };
} catch (error) {
  return {
    json: {
      error: "Could not parse output as JSON",
      original: outputStr
    }
  };
}
```

---

### Generating JSON Example Before AI Agent

```javascript
const example = {
  data: [
    {
      Item1: "This is a test",
      Somedata: {
        Frog: 6,
        Cat: 7,
        Dog: 9
      }
    }
  ]
};

return { json: { example: JSON.stringify(example) } };
```

Dans l’AI Agent, utilisez :

```text
"prompt": "Use this structure: {{ $json.example }}"
```

---

### Using `$fromAI` (nouvelle méthode)

```text
{{ $fromAI.json.specificProperty }}
```

Permet de référencer directement des champs du résultat IA sans analyse manuelle.

---

### Exemple d'appel HTTP depuis l'AI Agent

```json
{
  "url": "https://api.example.com/endpoint",
  "method": "POST",
  "headers": {
    "Content-Type": "application/json"
  },
  "bodyParametersUi": {
    "parameter": [
      {
        "name": "ids",
        "value": "{{ [\"ID\"] }}"
      }
    ]
  }
}
```

---

### Préserver les données d’entrée (ID, etc.)

```javascript
const originalId = $node["PreviousNode"].first().json.id;
const aiOutput = $json.output;

return {
  json: {
    id: originalId,
    aiResult: aiOutput
  }
};
```

---

### Traitement de plusieurs items avec l'AI Agent

```javascript
// En Code node avant AI Agent
const allItems = $input.all().map(item => item.json);

return {
  json: {
    combinedData: allItems,
    prompt: "Process all these items at once: " + JSON.stringify(allItems)
  }
};
```

---

Ces extraits complètent le **Comprehensive Guide to JSON Snippets for N8n Automation**, en couvrant :

* La structure fondamentale des données
* L’utilisation avancée du module **AI Agent**
* La gestion des sorties IA (format string, fusion, ID)
* Les intégrations HTTP avec AI
* Le traitement de lots avec prompt dynamique
* L’usage sécurisé des expressions JSON en entrée

Ces pratiques assurent une automatisation fiable, performante et extensible dans vos workflows n8n.

```json
{
  "options": {
    "systemMessage": "You are a helpful assistant. Always respond in valid JSON format following this structure:\n\n{\n  \"category\": \"[Category of the request]\",\n  \"response\": \"[Your detailed response]\",\n  \"nextSteps\": [\"step1\", \"step2\", \"etc\"]\n}\n\nEnsure your entire response is valid JSON."
  }
}
```

Explication : Cette configuration fournit une instruction explicite dans le `systemMessage` pour forcer l'agent IA à répondre dans un format JSON structuré. Cela réduit les erreurs de parsing et facilite l'intégration avec les nœuds suivants.

---

### Expressions N8n pour accéder aux données JSON

* Accéder à une propriété simple :

  ```text
  {{ $json.property1 }}
  ```

* Accéder à une propriété imbriquée :

  ```text
  {{ $json.parent.child.property }}
  ```

* Accéder à un champ d’un nœud précédent spécifique :

  ```text
  {{ $node["NomDuNœud"].json.property }}
  ```

Ces expressions sont essentielles pour le mappage dynamique de données dans les champs des nœuds, les prompts IA, les conditions IF, et plus encore. Utilisez-les pour personnaliser vos workflows en fonction des données traitées.




## Best Practices Summary
================================================================
FICHE MÉMO COMPLÈTE : DÉFINITIONS JSON DES NŒUDS n8n, TOUS LES OUTILS, NUANCES D’INTÉGRATION & MANIPULATION DE L’AGENT IA
=========================================================================================================================

Ce document combine une vue d’ensemble générale des structures JSON des nœuds n8n avec des sections détaillées sur chaque outil rencontré — des déclencheurs de chat et post-it aux intégrations avec Pinecone, Airtable, PostgreSQL, Google Docs, Google Calendar, Telegram, les API HTTP, SerpAPI, les outils de workflow, et plus encore. Il couvre également les bonnes pratiques pour manipuler le module Agent IA et aborde les problèmes courants de valeurs de propriétés lors de la génération de JSON via des LLM.

────────────────────────────────────────────────────────────

1. STRUCTURE JSON GÉNÉRALE DES NŒUDS n8n
   ────────────────────────────────────────────────────────────
   Vue d’ensemble :
   • Chaque nœud est défini comme un objet JSON avec un ensemble commun de clés.
   • Ces clés s’appliquent à tous les types de nœuds, qu’ils gèrent les déclencheurs, le traitement des données, la documentation ou les intégrations externes.

Champs principaux de haut niveau :
– **id :** Identifiant unique (généralement un UUID). Doit être unique dans un workflow.
– **name :** Étiquette lisible par l’humain (ex. : "Quand un message de chat est reçu", "Airtable - Mettre à jour les enregistr
